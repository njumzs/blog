{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/simpleblock/source/blog.jpg","path":"blog.jpg","modified":0,"renderable":1},{"_id":"themes/simpleblock/source/comment.ejs","path":"comment.ejs","modified":0,"renderable":1},{"_id":"themes/simpleblock/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/simpleblock/source/main.js","path":"main.js","modified":0,"renderable":1},{"_id":"themes/simpleblock/source/styles.css","path":"styles.css","modified":0,"renderable":1},{"_id":"themes/simpleblock/source/js/album.js","path":"js/album.js","modified":0,"renderable":1},{"_id":"themes/simpleblock/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/simpleblock/source/js/jquery-1.8.3.min.js","path":"js/jquery-1.8.3.min.js","modified":0,"renderable":1},{"_id":"themes/simpleblock/source/js/require.js","path":"js/require.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/album_list.md","hash":"d8604092581a7e43933474bb927a3b63a1f37dac","modified":1458735055466},{"_id":"themes/simpleblock/LICENSE","hash":"f08a91a1f35b7c6013647402feb7e5e028f1ccce","modified":1457447950206},{"_id":"themes/simpleblock/README.md","hash":"521796f52da65ab5abc565fd4444ed2d6632adbf","modified":1457447950206},{"_id":"themes/simpleblock/_config.yml","hash":"113fcc0dfdf807f196cad7f1133b8e6d3e01f36f","modified":1458735507058},{"_id":"themes/simpleblock/helpers.coffee","hash":"fd72bf70707e097886bdf41442fc3e26fc13449d","modified":1457447950206},{"_id":"themes/simpleblock/package.json","hash":"bb1aa05de259bad79ec8f26c37b596a3586075e2","modified":1457447950210},{"_id":"themes/simpleblock/languages/default.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1457447950206},{"_id":"source/_posts/2015-05-03#写在开头.mkd","hash":"51a600db9767749472136b8afa4c2df9f1d5877a","modified":1457531504150},{"_id":"source/_posts/2015-05-04#nagios dockerfile添加mysql监控.md","hash":"ec1de1f519abd70e16b86d6fe77273919138f23f","modified":1457528389950},{"_id":"source/_posts/2015-05-26#告别季.md","hash":"c035688a829621c18662cdf430d83d0644f5ddb0","modified":1457528266794},{"_id":"source/_posts/2015-07-24#linux搭建简单的vpn server.md","hash":"63a7666172a99a4ccfb0542aa7a522fb06f36884","modified":1458114318102},{"_id":"source/_posts/2016-02-25#用nginx反向代理docker来代替publish端口.md","hash":"be99be70a8175ed1fb493a22f32bd4216bd953b1","modified":1459128183558},{"_id":"source/_posts/2016-02-29#gitlab-docker更新指南.md","hash":"344a3c41d3dcad817965e241aacbee3c18a34fc6","modified":1457502826150},{"_id":"source/_posts/2016-03-08#docker远程API.md","hash":"883242be278039f4a9bd44b4b706dfeb54803ab6","modified":1457528129174},{"_id":"source/_posts/2016-03-19#ssh的密钥机制.md","hash":"5d45aba83e245c03ae61c8c7914f429c8b1a320a","modified":1458652416974},{"_id":"themes/simpleblock/layout/base.jade","hash":"34d317b2e7481ae9019163860da98d40041524e1","modified":1458742071426},{"_id":"themes/simpleblock/layout/index.jade","hash":"97fb295daf373ab48ef34527408f5e6c7ec52311","modified":1458739645218},{"_id":"themes/simpleblock/scripts/helpers.js","hash":"73e40e158ae8a50d3fc370bc95bc6a2c583a2275","modified":1457447950210},{"_id":"themes/simpleblock/source/blog.jpg","hash":"66659c4c40253bb7703e194892d29bb53abc20f4","modified":1457447950210},{"_id":"themes/simpleblock/source/comment.ejs","hash":"e1bfe3c6ce522874125cdfb502619ebcda2c55d8","modified":1459126160022},{"_id":"themes/simpleblock/source/favicon.png","hash":"1192beec5a334624fd602e84cf970d3a37005ec6","modified":1457447950210},{"_id":"themes/simpleblock/source/main.js","hash":"e26a4b525571ee1bc7a33ff28cc0aac25704dc07","modified":1458735972766},{"_id":"themes/simpleblock/source/styles.css","hash":"a8f62ab1fc83ee734e97ae73e36d96eb55186518","modified":1457447950210},{"_id":"themes/simpleblock/node_modules/.bin/marked","hash":"c321c5f1bb4a3eebbcd9567d3fa21a4371371377","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/.npmignore","hash":"15d008274a0cb39bd4c1e5fe67448455521d588e","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/.travis.yml","hash":"fed5f9b3fe841cdcb6692b8d7ce3e31bc6d0ee35","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/LICENSE","hash":"5ddde30228c2d459718a64a71f7df5cef833fa1a","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/Makefile","hash":"db2881743b9bb2561dee28907f21e45fa5101542","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/README.md","hash":"bf86db4cd881dec26167772b4671efac3a5e0dfe","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/bower.json","hash":"09bea18bec15f3dcbf9d189db3be964e7951f6b4","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/component.json","hash":"b1df6a1df57e341434618bec5ffa4f5a70b311c0","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/index.js","hash":"5ddf7807f931d19f61fa3405dd8e3d77b883c746","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/marked.min.js","hash":"8df06974b29d04bc982f97ed2779d7d915f39901","modified":1457447950210},{"_id":"themes/simpleblock/node_modules/marked/package.json","hash":"e3cc66146096d524f48086d7b2b0d0bb662dea73","modified":1457447950210},{"_id":"themes/simpleblock/source/js/album.js","hash":"d7720e33e2ebac51ef8d9668e0f0003b3d97c0b9","modified":1458741871750},{"_id":"themes/simpleblock/source/js/jquery.lazyload.js","hash":"9c96a225c963bd68adc363e553bac21700198fab","modified":1458739081702},{"_id":"themes/simpleblock/source/js/jquery-1.8.3.min.js","hash":"8b6babff47b8a9793f37036fd1b1a3ad41d38423","modified":1382691178000},{"_id":"themes/simpleblock/source/js/require.js","hash":"a937a464a171d21f40a0abd5ea16a226e877ec26","modified":1334963678000},{"_id":"themes/simpleblock/node_modules/marked/bin/marked","hash":"c321c5f1bb4a3eebbcd9567d3fa21a4371371377","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/doc/broken.md","hash":"71e1adf7a9fb5363f49207d73dcbdcecf637487c","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/doc/todo.md","hash":"b9c6e90df6c81da9945bc385ff81dc5782b30932","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/lib/marked.js","hash":"dc3923d8cf8fe3a2fa8c559531ed6ffd0f96908f","modified":1457447950206},{"_id":"themes/simpleblock/node_modules/marked/man/marked.1","hash":"80c6a26506a0420153851d5c90fb7009d60ea288","modified":1457447950206},{"_id":"public/album_list/index.html","hash":"205d57a1270c2ed8d38928049c874944e706b6f5","modified":1459660094053},{"_id":"public/2016/03/19/ssh-key/index.html","hash":"2ece7c48d68b8ee42c05e628165259741e47c173","modified":1459660094115},{"_id":"public/2016/03/08/docker远程API/index.html","hash":"1ba1de4f22a9c9c3e9ac0e685f1f62dca61490b8","modified":1459128229665},{"_id":"public/2016/02/29/igtlab-docker-update/index.html","hash":"b56de3e4b8bbd6118fbf22306d39ca2532efdc9d","modified":1459660094109},{"_id":"public/2016/02/25/nginx-docker/index.html","hash":"4bc029ddef1515424bf9cf614d6db1a3a3cd792e","modified":1459660094109},{"_id":"public/2015/07/24/vpn-server/index.html","hash":"1a02fe05ce809ec9bce7f20b0a11ab80de10ba49","modified":1459660094116},{"_id":"public/2015/05/26/say-bye/index.html","hash":"a0fdc185a2be444793fc36cb26b98493b4787fda","modified":1459660094110},{"_id":"public/2015/05/04/nagios-mysql/index.html","hash":"3d8c116bfe094bfef91778a6bb2325870a11ab4a","modified":1459660094110},{"_id":"public/2015/05/03/begin-of-blog/index.html","hash":"2dd143383da648ccbf3ba0ac5079a9b8c47d26a3","modified":1459660094110},{"_id":"public/archives/index.html","hash":"33108e727ebdd7391fdde3d172b1174be9d2cc03","modified":1459660094110},{"_id":"public/archives/page/2/index.html","hash":"37f390122670e8779b553a7ae76b652d8a12fcfb","modified":1459660094111},{"_id":"public/archives/page/3/index.html","hash":"39fbbec09c2433796e78d0e77520bdda22a28bb6","modified":1459660094114},{"_id":"public/archives/page/4/index.html","hash":"06e2dada0cc298e09ed25bf12988d9fec6c849b6","modified":1459660094111},{"_id":"public/archives/2015/index.html","hash":"f9f189146ce386d9e8e5eb354a2ee769883e8d88","modified":1459660094117},{"_id":"public/archives/2015/page/2/index.html","hash":"ccfc266177b2d8bc0f592a4392bd8ae2aa81d4b2","modified":1459660094119},{"_id":"public/archives/2015/05/index.html","hash":"acdd55f4b108352c44d8c844cfa03655a8d3cc43","modified":1459660094117},{"_id":"public/archives/2015/05/page/2/index.html","hash":"c14860c25de8b344d76e415f94349473b9c7bd40","modified":1459660094120},{"_id":"public/archives/2015/07/index.html","hash":"4c970f692880e4bfce9a2f948119ccdbe118f91a","modified":1459660094117},{"_id":"public/archives/2016/index.html","hash":"66ec9bbe4a4b6dd40303b05fdaa4c1ca2d356a56","modified":1459660094117},{"_id":"public/archives/2016/page/2/index.html","hash":"785886717985ef2a9f96d6176f1bbeb3cfcb89fa","modified":1459660094119},{"_id":"public/archives/2016/02/index.html","hash":"9a5b429491d96760054ab06969523fa56113d502","modified":1459660094118},{"_id":"public/archives/2016/03/index.html","hash":"df1b933615fda4d734e02431161aee93b2a6a251","modified":1459660094119},{"_id":"public/index.html","hash":"859d3e79f75e3ed5ce93427bdbb5e70cf2458397","modified":1459660094119},{"_id":"public/page/2/index.html","hash":"b5c744767412d21d5d18ef5700fbab34ba49de47","modified":1459660094120},{"_id":"public/page/3/index.html","hash":"1008917cfcd82ecd626552efce553deffdbef0e8","modified":1459660094120},{"_id":"public/page/4/index.html","hash":"bd1dbe43bbf12773eb0db432602124798faeee58","modified":1459660094121},{"_id":"public/tags/记录/index.html","hash":"7fcd1dc4712fa14213d14d1710dbbc4897a1fa9a","modified":1459660094121},{"_id":"public/tags/nagios/index.html","hash":"21bd3e10638a1d133db42df8e4d9a68b3a58346a","modified":1459660094121},{"_id":"public/tags/mysql/index.html","hash":"e55ad405ceef4dfc57770592e86e4fafe4f1ec11","modified":1459660094121},{"_id":"public/tags/docker/index.html","hash":"7d8f3e3018537692a37ae7c08346419fc1df25a1","modified":1459660094121},{"_id":"public/tags/docker/page/2/index.html","hash":"e1653c66cda86da0c23ec2588d30293f4c460bd5","modified":1459128229679},{"_id":"public/tags/生活/index.html","hash":"ab88508c10fca8d3bdf055c38d7a1cd9c2f1e876","modified":1459660094123},{"_id":"public/tags/vpn-server/index.html","hash":"c7a2916f8e2c48c02f042457d216fcd091aa360b","modified":1459660094122},{"_id":"public/tags/linux/index.html","hash":"35c702d5d5cf42c24a2457e210f60f5190fcbac3","modified":1459660094121},{"_id":"public/tags/nginx/index.html","hash":"0bc15dfef7eda8344c286e970916b427d761b57b","modified":1459660094122},{"_id":"public/tags/gitlab/index.html","hash":"42b582211d1c6b5e8600802f27af3116be659da8","modified":1459660094123},{"_id":"public/tags/ssh/index.html","hash":"eb15b166432cbde415417886e771913a2727612f","modified":1459660094123},{"_id":"source/_posts/2016-04-03#adb无线连接.md","hash":"2780cec56257b9b78f98a94350772f898dbf6791","modified":1459660039054},{"_id":"public/2016/04/03/adb无线连接/index.html","hash":"5be6a8ebf149a26da6c62ecc3e19b4df3f4b2d6c","modified":1459660094109},{"_id":"public/archives/2016/04/index.html","hash":"0fb2ca2dc8fefe3a036fed52c8aafaa0baf3d3e5","modified":1459660094128},{"_id":"public/tags/Android/index.html","hash":"5003d02ec03d5efdca303808375254a5623812e1","modified":1459660094128}],"Category":[],"Data":[],"Page":[{"title":"album","noDate":true,"_content":"\n<link type=\"text/css\" href=\"/fancybox/jquery.fancybox.css\" rel=\"stylesheet\">\n<div class=\"instagram\"><section class=\"archives album\"><ul class=\"img-box-ul\"></ul></section></div>\n<script src=\"/js/album.js\"><script>\n","source":"album_list.md","raw":"---\ntitle: album\npermalink: album_list/\nnoDate: true\n---\n\n<link type=\"text/css\" href=\"/fancybox/jquery.fancybox.css\" rel=\"stylesheet\">\n<div class=\"instagram\"><section class=\"archives album\"><ul class=\"img-box-ul\"></ul></section></div>\n<script src=\"/js/album.js\"><script>\n","date":"2016-03-23T12:10:55.466Z","updated":"2016-03-23T12:10:55.466Z","path":"album_list/index.html","comments":1,"layout":"page","_id":"cimba548x000006om475c6mpj","content":"<p><link type=\"text/css\" href=\"/fancybox/jquery.fancybox.css\" rel=\"stylesheet\"></p>\n<p><div class=\"instagram\"><section class=\"archives album\"><ul class=\"img-box-ul\"></ul></section></div></p>\n<p><script src=\"/js/album.js\"><script></p>\n</script></p>","excerpt":"","more":"<p><link type=\"text/css\" href=\"/fancybox/jquery.fancybox.css\" rel=\"stylesheet\"></p>\n<p><div class=\"instagram\"><section class=\"archives album\"><ul class=\"img-box-ul\"></ul></section></div></p>\n<p><script src=\"/js/album.js\"><script></p>\n"}],"Post":[{"title":"写在开头","date":"2015-05-03T00:00:00.000Z","_content":" \n有一段时间我习惯用Evernote记录手头的一些东西，这个app在各种平台上都有插件可以用，还是蛮方便的。 算是很自欺欺人的记忆吧，过去偶尔会有灵光一现有一些千奇百怪想法的时候，我也会作简单的记录。可是终究是太懒了，所以硬盘里总是有无标题文档1.txt，无标题文档2.txt....这样莫名奇妙的文本，日后需要，检索到的难度可想而知。现在越来越没有自己的想法，越来越去习惯追随所谓的规矩不敢轻易逾越，越来越羡慕那些拍脑袋就有idea的大神们，很大程度上和我的坏习惯有逃不开的关系。再后来，我习惯使用了github，情况才变得好一些。\n\n手头的事情一多起来，经常会寥寥数笔作简单的记录，此后便扔在一边不去拾掇打理。过段时间再躬首俯拾，似曾相识的东西也会变得恍惚而又陌生起来。这学期接触到一些新的东西，比如，热到不行的docker，nagios，有实用价值的中文资料很少，我自己还是花了很多时间去读原汁原味的英文文档，看老外的帖子，一些经验想法走心地记录下来，或许可备自己日后不时之需。\n   \n因此，我打算拾掇一下了。搭一个blog出来，方便随身携带和日后迁移。最初我想用python实现大致的静态的后台,用jinjia2之类的框架来简单地搞一个前台出来。对于我这种没有审美又有一些偏执的异类来说，做前端开发无异于慢性自杀。我把自己的需求精简为:\n   \n   * markdown来post\n   * git来同步,方便后期迁移\n   * 不需要数据库软件,只用文本存储就ok\n   * 前端不要太复杂,静态就可以了\n   \n整个过程持续了俩个月之久，四月份有一段时间忙得晕头转向，每天混沌到像个怨妇，整个进度就此耽搁了下来。4月30号在东海的一艘破渔船上，劈头盖脸地风吹浪打里打撑着一把破伞，我度过了迄今为止人生最凄凉的一个夜晚，闭着双眼懵里懵懂间一头栽进五月的海里。突然觉得时间会过得如此之快，再不完结就要给本科留一个真正的烂尾了。之后假期结束4号上午开始搞，一切都还算顺利，很快就部署好了。\n\n但愿可以不轻易地丢失初衷，慷慨踏实地走。我一直相信，革新和发明是小部分人的天职，绝大多数的人只靠口耳相传和动手实践就可以许诺自己体面的生活了，雷布斯说，只要站在风口，猪也能飞起来。干了这碗鸡汤吧。 最后谢谢你读到这里.\n  \n","source":"_posts/2015-05-03#写在开头.mkd","raw":"---\ntitle: 写在开头\ntags:\n    - 记录\npermalink: begin-of-blog\ndate: 2015-05-03\n---\n \n有一段时间我习惯用Evernote记录手头的一些东西，这个app在各种平台上都有插件可以用，还是蛮方便的。 算是很自欺欺人的记忆吧，过去偶尔会有灵光一现有一些千奇百怪想法的时候，我也会作简单的记录。可是终究是太懒了，所以硬盘里总是有无标题文档1.txt，无标题文档2.txt....这样莫名奇妙的文本，日后需要，检索到的难度可想而知。现在越来越没有自己的想法，越来越去习惯追随所谓的规矩不敢轻易逾越，越来越羡慕那些拍脑袋就有idea的大神们，很大程度上和我的坏习惯有逃不开的关系。再后来，我习惯使用了github，情况才变得好一些。\n\n手头的事情一多起来，经常会寥寥数笔作简单的记录，此后便扔在一边不去拾掇打理。过段时间再躬首俯拾，似曾相识的东西也会变得恍惚而又陌生起来。这学期接触到一些新的东西，比如，热到不行的docker，nagios，有实用价值的中文资料很少，我自己还是花了很多时间去读原汁原味的英文文档，看老外的帖子，一些经验想法走心地记录下来，或许可备自己日后不时之需。\n   \n因此，我打算拾掇一下了。搭一个blog出来，方便随身携带和日后迁移。最初我想用python实现大致的静态的后台,用jinjia2之类的框架来简单地搞一个前台出来。对于我这种没有审美又有一些偏执的异类来说，做前端开发无异于慢性自杀。我把自己的需求精简为:\n   \n   * markdown来post\n   * git来同步,方便后期迁移\n   * 不需要数据库软件,只用文本存储就ok\n   * 前端不要太复杂,静态就可以了\n   \n整个过程持续了俩个月之久，四月份有一段时间忙得晕头转向，每天混沌到像个怨妇，整个进度就此耽搁了下来。4月30号在东海的一艘破渔船上，劈头盖脸地风吹浪打里打撑着一把破伞，我度过了迄今为止人生最凄凉的一个夜晚，闭着双眼懵里懵懂间一头栽进五月的海里。突然觉得时间会过得如此之快，再不完结就要给本科留一个真正的烂尾了。之后假期结束4号上午开始搞，一切都还算顺利，很快就部署好了。\n\n但愿可以不轻易地丢失初衷，慷慨踏实地走。我一直相信，革新和发明是小部分人的天职，绝大多数的人只靠口耳相传和动手实践就可以许诺自己体面的生活了，雷布斯说，只要站在风口，猪也能飞起来。干了这碗鸡汤吧。 最后谢谢你读到这里.\n  \n","slug":"begin-of-blog","published":1,"updated":"2016-03-09T13:51:44.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimba54uk000106ompqyxn28d","content":"<p>有一段时间我习惯用Evernote记录手头的一些东西，这个app在各种平台上都有插件可以用，还是蛮方便的。 算是很自欺欺人的记忆吧，过去偶尔会有灵光一现有一些千奇百怪想法的时候，我也会作简单的记录。可是终究是太懒了，所以硬盘里总是有无标题文档1.txt，无标题文档2.txt….这样莫名奇妙的文本，日后需要，检索到的难度可想而知。现在越来越没有自己的想法，越来越去习惯追随所谓的规矩不敢轻易逾越，越来越羡慕那些拍脑袋就有idea的大神们，很大程度上和我的坏习惯有逃不开的关系。再后来，我习惯使用了github，情况才变得好一些。</p>\n<p>手头的事情一多起来，经常会寥寥数笔作简单的记录，此后便扔在一边不去拾掇打理。过段时间再躬首俯拾，似曾相识的东西也会变得恍惚而又陌生起来。这学期接触到一些新的东西，比如，热到不行的docker，nagios，有实用价值的中文资料很少，我自己还是花了很多时间去读原汁原味的英文文档，看老外的帖子，一些经验想法走心地记录下来，或许可备自己日后不时之需。</p>\n<p>因此，我打算拾掇一下了。搭一个blog出来，方便随身携带和日后迁移。最初我想用python实现大致的静态的后台,用jinjia2之类的框架来简单地搞一个前台出来。对于我这种没有审美又有一些偏执的异类来说，做前端开发无异于慢性自杀。我把自己的需求精简为:</p>\n<ul>\n<li>markdown来post</li>\n<li>git来同步,方便后期迁移</li>\n<li>不需要数据库软件,只用文本存储就ok</li>\n<li>前端不要太复杂,静态就可以了</li>\n</ul>\n<p>整个过程持续了俩个月之久，四月份有一段时间忙得晕头转向，每天混沌到像个怨妇，整个进度就此耽搁了下来。4月30号在东海的一艘破渔船上，劈头盖脸地风吹浪打里打撑着一把破伞，我度过了迄今为止人生最凄凉的一个夜晚，闭着双眼懵里懵懂间一头栽进五月的海里。突然觉得时间会过得如此之快，再不完结就要给本科留一个真正的烂尾了。之后假期结束4号上午开始搞，一切都还算顺利，很快就部署好了。</p>\n<p>但愿可以不轻易地丢失初衷，慷慨踏实地走。我一直相信，革新和发明是小部分人的天职，绝大多数的人只靠口耳相传和动手实践就可以许诺自己体面的生活了，雷布斯说，只要站在风口，猪也能飞起来。干了这碗鸡汤吧。 最后谢谢你读到这里.</p>\n","excerpt":"","more":"<p>有一段时间我习惯用Evernote记录手头的一些东西，这个app在各种平台上都有插件可以用，还是蛮方便的。 算是很自欺欺人的记忆吧，过去偶尔会有灵光一现有一些千奇百怪想法的时候，我也会作简单的记录。可是终究是太懒了，所以硬盘里总是有无标题文档1.txt，无标题文档2.txt….这样莫名奇妙的文本，日后需要，检索到的难度可想而知。现在越来越没有自己的想法，越来越去习惯追随所谓的规矩不敢轻易逾越，越来越羡慕那些拍脑袋就有idea的大神们，很大程度上和我的坏习惯有逃不开的关系。再后来，我习惯使用了github，情况才变得好一些。</p>\n<p>手头的事情一多起来，经常会寥寥数笔作简单的记录，此后便扔在一边不去拾掇打理。过段时间再躬首俯拾，似曾相识的东西也会变得恍惚而又陌生起来。这学期接触到一些新的东西，比如，热到不行的docker，nagios，有实用价值的中文资料很少，我自己还是花了很多时间去读原汁原味的英文文档，看老外的帖子，一些经验想法走心地记录下来，或许可备自己日后不时之需。</p>\n<p>因此，我打算拾掇一下了。搭一个blog出来，方便随身携带和日后迁移。最初我想用python实现大致的静态的后台,用jinjia2之类的框架来简单地搞一个前台出来。对于我这种没有审美又有一些偏执的异类来说，做前端开发无异于慢性自杀。我把自己的需求精简为:</p>\n<ul>\n<li>markdown来post</li>\n<li>git来同步,方便后期迁移</li>\n<li>不需要数据库软件,只用文本存储就ok</li>\n<li>前端不要太复杂,静态就可以了</li>\n</ul>\n<p>整个过程持续了俩个月之久，四月份有一段时间忙得晕头转向，每天混沌到像个怨妇，整个进度就此耽搁了下来。4月30号在东海的一艘破渔船上，劈头盖脸地风吹浪打里打撑着一把破伞，我度过了迄今为止人生最凄凉的一个夜晚，闭着双眼懵里懵懂间一头栽进五月的海里。突然觉得时间会过得如此之快，再不完结就要给本科留一个真正的烂尾了。之后假期结束4号上午开始搞，一切都还算顺利，很快就部署好了。</p>\n<p>但愿可以不轻易地丢失初衷，慷慨踏实地走。我一直相信，革新和发明是小部分人的天职，绝大多数的人只靠口耳相传和动手实践就可以许诺自己体面的生活了，雷布斯说，只要站在风口，猪也能飞起来。干了这碗鸡汤吧。 最后谢谢你读到这里.</p>\n"},{"title":"nagios dockerfile添加mysql监控","date":"2015-05-04T00:00:00.000Z","_content":"\n## 配置过程:\n\n确保nagios宿主机即监控主节点安装了mysql-client，被监控节点不需要安装任何插件,只需要mysql service正常running即可。首先确保有这样的一个user(以下的操作发生在被监控节点):\n\nThe following command will create a user named \"nagios\" with a password \"password\" and grant him access on the local MySQL DB.\n\n    CREATE USER 'nagios'@'localhost' IDENTIFIED BY 'password'; \n\nThe following command issues full permissions to the nagios user.\n\n    GRANT USAGE ON *.* TO 'nagios'@'localhost';\n\nThe following command will create a user named \"nagios\" with a password \"password\" and allow him to access the DB from any (%) location.\n\n    CREATE USER 'nagios'@'%' IDENTIFIED BY 'password'; \n\nThe following command issues full permissions to the nagios user from any location.\n\n    GRANT USAGE ON *.* TO 'nagios'@'%';\n\n    flush privileges;\n\n我使用的是**CREATE USER 'nagios'@'%' IDENTIFIED BY 'password';** \n\n此外,注释掉mysql配置文件my.cnf中如下一行,\n\n    bind-address   =   127.0.0.1\n\n## 在dockerfile里边添加(以下的操作都发生在nagios主节点)\n\n**RUN wget http://labs.consol.de/download/shinken-nagios-plugins/check_mysql_health-2.1.8.2.tar.gz && tar -xvzf check_mysql_health-2.1.8.2.tar.gz && cd check_mysql_health-2.1.8.2 &&  ./configure --with-nagios-user=${NAGIOS_USER} --with-nagios-group=${NAGIOS_USER} && make && make install**\n\n编译安装软件之后,在**/usr/local/nagios/libexec**可以看到 check_mysql_health插件(默认安装)\n\n在**remotehost.cfg**中添加command和service\n\n    define command{\n    command_name check_mysql_health\n    command_line $USER1$/check_mysql_health --hostname $HOSTADDRESS$ --port $ARG1$ --username $ARG2$ --         password $ARG3$ --mode $ARG4$ \n    }\n\n    define service{\n    use generic-service\n    host_name localhost\n    service_description MySQL_threads-connected\n    check_command check_mysql_health!3306!user!password!threads-connected\n    }\n    \n    define service{\n    use generic-service\n    host_name localhost\n    service_description MySQL_connection-time\n    check_command check_mysql_health!3306!user!password!connection-time\n    }\n\n    define service{\n    use generic-service\n    host_name localhost\n    service_description MySQL_uptime\n    check_command check_mysql_health!3306!user!password!uptime\n    }\n\n注：\n\n* user和password具体替换\n*hots_name具体指定\n\n然后运行\n\n    service nagios restart\n\n注意,在command的定义中,还可以添加的参数包括:\n\n* --database  dbname (默认是information_schema )\n* --warning  range\n* --critical range \n\n相应的,在service定义中就可以多使用!符号把参数传进去,后俩个具体数值我不清楚设置多少合适,所以就使用了默认值\n,这样应该就可以了\n\n## 参考链接:\n\n* [文档一](http://labs.consol.de/nagios/check_mysql_health/)\n* [文档二](http://exchange.nagios.org/directory/MySQL/check_mysql_health/details)\n* [monitoring mysql usingnagios](http://www.yoyoclouds.com/2014/08/monitoring-mysql-using-nagios.html)\n\n","source":"_posts/2015-05-04#nagios dockerfile添加mysql监控.md","raw":"---\ntitle: nagios dockerfile添加mysql监控\npermalink: nagios-mysql\ntags:\n    - nagios\n    - mysql\n    - docker\ndate: 2015-05-04\n---\n\n## 配置过程:\n\n确保nagios宿主机即监控主节点安装了mysql-client，被监控节点不需要安装任何插件,只需要mysql service正常running即可。首先确保有这样的一个user(以下的操作发生在被监控节点):\n\nThe following command will create a user named \"nagios\" with a password \"password\" and grant him access on the local MySQL DB.\n\n    CREATE USER 'nagios'@'localhost' IDENTIFIED BY 'password'; \n\nThe following command issues full permissions to the nagios user.\n\n    GRANT USAGE ON *.* TO 'nagios'@'localhost';\n\nThe following command will create a user named \"nagios\" with a password \"password\" and allow him to access the DB from any (%) location.\n\n    CREATE USER 'nagios'@'%' IDENTIFIED BY 'password'; \n\nThe following command issues full permissions to the nagios user from any location.\n\n    GRANT USAGE ON *.* TO 'nagios'@'%';\n\n    flush privileges;\n\n我使用的是**CREATE USER 'nagios'@'%' IDENTIFIED BY 'password';** \n\n此外,注释掉mysql配置文件my.cnf中如下一行,\n\n    bind-address   =   127.0.0.1\n\n## 在dockerfile里边添加(以下的操作都发生在nagios主节点)\n\n**RUN wget http://labs.consol.de/download/shinken-nagios-plugins/check_mysql_health-2.1.8.2.tar.gz && tar -xvzf check_mysql_health-2.1.8.2.tar.gz && cd check_mysql_health-2.1.8.2 &&  ./configure --with-nagios-user=${NAGIOS_USER} --with-nagios-group=${NAGIOS_USER} && make && make install**\n\n编译安装软件之后,在**/usr/local/nagios/libexec**可以看到 check_mysql_health插件(默认安装)\n\n在**remotehost.cfg**中添加command和service\n\n    define command{\n    command_name check_mysql_health\n    command_line $USER1$/check_mysql_health --hostname $HOSTADDRESS$ --port $ARG1$ --username $ARG2$ --         password $ARG3$ --mode $ARG4$ \n    }\n\n    define service{\n    use generic-service\n    host_name localhost\n    service_description MySQL_threads-connected\n    check_command check_mysql_health!3306!user!password!threads-connected\n    }\n    \n    define service{\n    use generic-service\n    host_name localhost\n    service_description MySQL_connection-time\n    check_command check_mysql_health!3306!user!password!connection-time\n    }\n\n    define service{\n    use generic-service\n    host_name localhost\n    service_description MySQL_uptime\n    check_command check_mysql_health!3306!user!password!uptime\n    }\n\n注：\n\n* user和password具体替换\n*hots_name具体指定\n\n然后运行\n\n    service nagios restart\n\n注意,在command的定义中,还可以添加的参数包括:\n\n* --database  dbname (默认是information_schema )\n* --warning  range\n* --critical range \n\n相应的,在service定义中就可以多使用!符号把参数传进去,后俩个具体数值我不清楚设置多少合适,所以就使用了默认值\n,这样应该就可以了\n\n## 参考链接:\n\n* [文档一](http://labs.consol.de/nagios/check_mysql_health/)\n* [文档二](http://exchange.nagios.org/directory/MySQL/check_mysql_health/details)\n* [monitoring mysql usingnagios](http://www.yoyoclouds.com/2014/08/monitoring-mysql-using-nagios.html)\n\n","slug":"nagios-mysql","published":1,"updated":"2016-03-09T12:59:49.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimba54uv000206om27cptimk","content":"<h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程:\"></a>配置过程:</h2><p>确保nagios宿主机即监控主节点安装了mysql-client，被监控节点不需要安装任何插件,只需要mysql service正常running即可。首先确保有这样的一个user(以下的操作发生在被监控节点):</p>\n<p>The following command will create a user named “nagios” with a password “password” and grant him access on the local MySQL DB.</p>\n<pre><code>CREATE USER &apos;nagios&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;; \n</code></pre><p>The following command issues full permissions to the nagios user.</p>\n<pre><code>GRANT USAGE ON *.* TO &apos;nagios&apos;@&apos;localhost&apos;;\n</code></pre><p>The following command will create a user named “nagios” with a password “password” and allow him to access the DB from any (%) location.</p>\n<pre><code>CREATE USER &apos;nagios&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;; \n</code></pre><p>The following command issues full permissions to the nagios user from any location.</p>\n<pre><code>GRANT USAGE ON *.* TO &apos;nagios&apos;@&apos;%&apos;;\n\nflush privileges;\n</code></pre><p>我使用的是<strong>CREATE USER ‘nagios’@’%’ IDENTIFIED BY ‘password’;</strong> </p>\n<p>此外,注释掉mysql配置文件my.cnf中如下一行,</p>\n<pre><code>bind-address   =   127.0.0.1\n</code></pre><h2 id=\"在dockerfile里边添加-以下的操作都发生在nagios主节点\"><a href=\"#在dockerfile里边添加-以下的操作都发生在nagios主节点\" class=\"headerlink\" title=\"在dockerfile里边添加(以下的操作都发生在nagios主节点)\"></a>在dockerfile里边添加(以下的操作都发生在nagios主节点)</h2><p><strong>RUN wget <a href=\"http://labs.consol.de/download/shinken-nagios-plugins/check_mysql_health-2.1.8.2.tar.gz\" target=\"_blank\" rel=\"external\">http://labs.consol.de/download/shinken-nagios-plugins/check_mysql_health-2.1.8.2.tar.gz</a> &amp;&amp; tar -xvzf check_mysql_health-2.1.8.2.tar.gz &amp;&amp; cd check_mysql_health-2.1.8.2 &amp;&amp;  ./configure –with-nagios-user=${NAGIOS_USER} –with-nagios-group=${NAGIOS_USER} &amp;&amp; make &amp;&amp; make install</strong></p>\n<p>编译安装软件之后,在<strong>/usr/local/nagios/libexec</strong>可以看到 check_mysql_health插件(默认安装)</p>\n<p>在<strong>remotehost.cfg</strong>中添加command和service</p>\n<pre><code>define command{\ncommand_name check_mysql_health\ncommand_line $USER1$/check_mysql_health --hostname $HOSTADDRESS$ --port $ARG1$ --username $ARG2$ --         password $ARG3$ --mode $ARG4$ \n}\n\ndefine service{\nuse generic-service\nhost_name localhost\nservice_description MySQL_threads-connected\ncheck_command check_mysql_health!3306!user!password!threads-connected\n}\n\ndefine service{\nuse generic-service\nhost_name localhost\nservice_description MySQL_connection-time\ncheck_command check_mysql_health!3306!user!password!connection-time\n}\n\ndefine service{\nuse generic-service\nhost_name localhost\nservice_description MySQL_uptime\ncheck_command check_mysql_health!3306!user!password!uptime\n}\n</code></pre><p>注：</p>\n<ul>\n<li>user和password具体替换<br>*hots_name具体指定</li>\n</ul>\n<p>然后运行</p>\n<pre><code>service nagios restart\n</code></pre><p>注意,在command的定义中,还可以添加的参数包括:</p>\n<ul>\n<li>–database  dbname (默认是information_schema )</li>\n<li>–warning  range</li>\n<li>–critical range </li>\n</ul>\n<p>相应的,在service定义中就可以多使用!符号把参数传进去,后俩个具体数值我不清楚设置多少合适,所以就使用了默认值<br>,这样应该就可以了</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接:\"></a>参考链接:</h2><ul>\n<li><a href=\"http://labs.consol.de/nagios/check_mysql_health/\" target=\"_blank\" rel=\"external\">文档一</a></li>\n<li><a href=\"http://exchange.nagios.org/directory/MySQL/check_mysql_health/details\" target=\"_blank\" rel=\"external\">文档二</a></li>\n<li><a href=\"http://www.yoyoclouds.com/2014/08/monitoring-mysql-using-nagios.html\" target=\"_blank\" rel=\"external\">monitoring mysql usingnagios</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程:\"></a>配置过程:</h2><p>确保nagios宿主机即监控主节点安装了mysql-client，被监控节点不需要安装任何插件,只需要mysql service正常running即可。首先确保有这样的一个user(以下的操作发生在被监控节点):</p>\n<p>The following command will create a user named “nagios” with a password “password” and grant him access on the local MySQL DB.</p>\n<pre><code>CREATE USER &apos;nagios&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;; \n</code></pre><p>The following command issues full permissions to the nagios user.</p>\n<pre><code>GRANT USAGE ON *.* TO &apos;nagios&apos;@&apos;localhost&apos;;\n</code></pre><p>The following command will create a user named “nagios” with a password “password” and allow him to access the DB from any (%) location.</p>\n<pre><code>CREATE USER &apos;nagios&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;; \n</code></pre><p>The following command issues full permissions to the nagios user from any location.</p>\n<pre><code>GRANT USAGE ON *.* TO &apos;nagios&apos;@&apos;%&apos;;\n\nflush privileges;\n</code></pre><p>我使用的是<strong>CREATE USER ‘nagios’@’%’ IDENTIFIED BY ‘password’;</strong> </p>\n<p>此外,注释掉mysql配置文件my.cnf中如下一行,</p>\n<pre><code>bind-address   =   127.0.0.1\n</code></pre><h2 id=\"在dockerfile里边添加-以下的操作都发生在nagios主节点\"><a href=\"#在dockerfile里边添加-以下的操作都发生在nagios主节点\" class=\"headerlink\" title=\"在dockerfile里边添加(以下的操作都发生在nagios主节点)\"></a>在dockerfile里边添加(以下的操作都发生在nagios主节点)</h2><p><strong>RUN wget <a href=\"http://labs.consol.de/download/shinken-nagios-plugins/check_mysql_health-2.1.8.2.tar.gz\">http://labs.consol.de/download/shinken-nagios-plugins/check_mysql_health-2.1.8.2.tar.gz</a> &amp;&amp; tar -xvzf check_mysql_health-2.1.8.2.tar.gz &amp;&amp; cd check_mysql_health-2.1.8.2 &amp;&amp;  ./configure –with-nagios-user=${NAGIOS_USER} –with-nagios-group=${NAGIOS_USER} &amp;&amp; make &amp;&amp; make install</strong></p>\n<p>编译安装软件之后,在<strong>/usr/local/nagios/libexec</strong>可以看到 check_mysql_health插件(默认安装)</p>\n<p>在<strong>remotehost.cfg</strong>中添加command和service</p>\n<pre><code>define command{\ncommand_name check_mysql_health\ncommand_line $USER1$/check_mysql_health --hostname $HOSTADDRESS$ --port $ARG1$ --username $ARG2$ --         password $ARG3$ --mode $ARG4$ \n}\n\ndefine service{\nuse generic-service\nhost_name localhost\nservice_description MySQL_threads-connected\ncheck_command check_mysql_health!3306!user!password!threads-connected\n}\n\ndefine service{\nuse generic-service\nhost_name localhost\nservice_description MySQL_connection-time\ncheck_command check_mysql_health!3306!user!password!connection-time\n}\n\ndefine service{\nuse generic-service\nhost_name localhost\nservice_description MySQL_uptime\ncheck_command check_mysql_health!3306!user!password!uptime\n}\n</code></pre><p>注：</p>\n<ul>\n<li>user和password具体替换<br>*hots_name具体指定</li>\n</ul>\n<p>然后运行</p>\n<pre><code>service nagios restart\n</code></pre><p>注意,在command的定义中,还可以添加的参数包括:</p>\n<ul>\n<li>–database  dbname (默认是information_schema )</li>\n<li>–warning  range</li>\n<li>–critical range </li>\n</ul>\n<p>相应的,在service定义中就可以多使用!符号把参数传进去,后俩个具体数值我不清楚设置多少合适,所以就使用了默认值<br>,这样应该就可以了</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接:\"></a>参考链接:</h2><ul>\n<li><a href=\"http://labs.consol.de/nagios/check_mysql_health/\">文档一</a></li>\n<li><a href=\"http://exchange.nagios.org/directory/MySQL/check_mysql_health/details\">文档二</a></li>\n<li><a href=\"http://www.yoyoclouds.com/2014/08/monitoring-mysql-using-nagios.html\">monitoring mysql usingnagios</a></li>\n</ul>\n"},{"title":"告别季","date":"2015-05-26T00:00:00.000Z","_content":"\n今天是5月26号，周二，刚刚交掉毕业论文还不久。也恰好在一周之前，我从家里返回南京，走出站口，静默立在玄武湖畔，浸润着空气中氤氲着的大团湿气，不远处的紫峰大厦在雾霭里若隐若现，偌大的城市里，无边际的渺小感无力感纷至袭来，我竟会分外失落。\n\n回家是送奶奶走最后一程的。尽管在我们的民族里，死亡永远是一种禁忌，所有涉及到生死的话题都应该是沉痛的．但是回去之前，我还是给自己找了一千个不要哭出来的理由。可是真等到诀别那天，老人颤颤巍巍的样子终于隐隐约约出现在眼前，念想最后几年健在的时候，每次回去临走时，爷爷奶奶站在车门口流连不舍的情形，光影交错，恍若昨日，我一头扎进记忆的堆里拔不出来，防御的墙被连根拔起，彻底摧毁，哭得稀里哗啦。对孱弱生命的敬畏，就像面对无边暗夜里风中摇曳的残烛，你知道它很快会灭，可是总想，光明总是好的，还是灭得晚些罢。\n\n老家院子里有一颗杏树，许多年之前，爷爷奶奶都在的那些夏天，他们总是细心照看着来来往往的路人，想要把最好吃的大黄杏留给他们的儿孙。大家都在外边奔波忙碌，一年到头回去的次数很少，所以这种细微的感情从未被悉心察觉感怀领悟。如今，豌豆大小的的绿果子依旧缀满枝头，格外丰硕繁盛，可是曾经呵护过它们的主人却都不在了，抽丝剥茧般地一下子抽离了偌大院子里的最后一丝人气。摘几颗放在嘴里，很酸很涩．不知道到这个夏天也要溜掉的时候，还会存留多少果子在摇曳依旧的枝头，大概也没人会在意了吧．\n\n有一年，这棵树的一个枝桠死掉了，爷爷一把板斧把它砍了去，整棵树才幸免于难活到现在，长得愈发健壮。如今，它竟成了这座孤零零院子里的主人，阳光透过大片的叶子落在地上，变得斑驳摇曳，跳动的光影里勾连起关于这座院子数不尽的斑驳的记忆。\n\n终于到了和本科生活道别的时候，也很快要和一大批小伙伴说再见了．爷爷奶奶生于斯长于斯葬于斯的黄土地，那里我残留的童年，流逝的过往，若和他们有一线牵连，也是要一并再见了的．可是我还有新的一段路要接着走下去．\n\n","source":"_posts/2015-05-26#告别季.md","raw":"---\ntitle: 告别季\npermalink: say-bye\ntags:\n    - 生活\ndate: 2015-05-26\n---\n\n今天是5月26号，周二，刚刚交掉毕业论文还不久。也恰好在一周之前，我从家里返回南京，走出站口，静默立在玄武湖畔，浸润着空气中氤氲着的大团湿气，不远处的紫峰大厦在雾霭里若隐若现，偌大的城市里，无边际的渺小感无力感纷至袭来，我竟会分外失落。\n\n回家是送奶奶走最后一程的。尽管在我们的民族里，死亡永远是一种禁忌，所有涉及到生死的话题都应该是沉痛的．但是回去之前，我还是给自己找了一千个不要哭出来的理由。可是真等到诀别那天，老人颤颤巍巍的样子终于隐隐约约出现在眼前，念想最后几年健在的时候，每次回去临走时，爷爷奶奶站在车门口流连不舍的情形，光影交错，恍若昨日，我一头扎进记忆的堆里拔不出来，防御的墙被连根拔起，彻底摧毁，哭得稀里哗啦。对孱弱生命的敬畏，就像面对无边暗夜里风中摇曳的残烛，你知道它很快会灭，可是总想，光明总是好的，还是灭得晚些罢。\n\n老家院子里有一颗杏树，许多年之前，爷爷奶奶都在的那些夏天，他们总是细心照看着来来往往的路人，想要把最好吃的大黄杏留给他们的儿孙。大家都在外边奔波忙碌，一年到头回去的次数很少，所以这种细微的感情从未被悉心察觉感怀领悟。如今，豌豆大小的的绿果子依旧缀满枝头，格外丰硕繁盛，可是曾经呵护过它们的主人却都不在了，抽丝剥茧般地一下子抽离了偌大院子里的最后一丝人气。摘几颗放在嘴里，很酸很涩．不知道到这个夏天也要溜掉的时候，还会存留多少果子在摇曳依旧的枝头，大概也没人会在意了吧．\n\n有一年，这棵树的一个枝桠死掉了，爷爷一把板斧把它砍了去，整棵树才幸免于难活到现在，长得愈发健壮。如今，它竟成了这座孤零零院子里的主人，阳光透过大片的叶子落在地上，变得斑驳摇曳，跳动的光影里勾连起关于这座院子数不尽的斑驳的记忆。\n\n终于到了和本科生活道别的时候，也很快要和一大批小伙伴说再见了．爷爷奶奶生于斯长于斯葬于斯的黄土地，那里我残留的童年，流逝的过往，若和他们有一线牵连，也是要一并再见了的．可是我还有新的一段路要接着走下去．\n\n","slug":"say-bye","published":1,"updated":"2016-03-09T12:57:46.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimba54v7000406omft2xvx4p","content":"<p>今天是5月26号，周二，刚刚交掉毕业论文还不久。也恰好在一周之前，我从家里返回南京，走出站口，静默立在玄武湖畔，浸润着空气中氤氲着的大团湿气，不远处的紫峰大厦在雾霭里若隐若现，偌大的城市里，无边际的渺小感无力感纷至袭来，我竟会分外失落。</p>\n<p>回家是送奶奶走最后一程的。尽管在我们的民族里，死亡永远是一种禁忌，所有涉及到生死的话题都应该是沉痛的．但是回去之前，我还是给自己找了一千个不要哭出来的理由。可是真等到诀别那天，老人颤颤巍巍的样子终于隐隐约约出现在眼前，念想最后几年健在的时候，每次回去临走时，爷爷奶奶站在车门口流连不舍的情形，光影交错，恍若昨日，我一头扎进记忆的堆里拔不出来，防御的墙被连根拔起，彻底摧毁，哭得稀里哗啦。对孱弱生命的敬畏，就像面对无边暗夜里风中摇曳的残烛，你知道它很快会灭，可是总想，光明总是好的，还是灭得晚些罢。</p>\n<p>老家院子里有一颗杏树，许多年之前，爷爷奶奶都在的那些夏天，他们总是细心照看着来来往往的路人，想要把最好吃的大黄杏留给他们的儿孙。大家都在外边奔波忙碌，一年到头回去的次数很少，所以这种细微的感情从未被悉心察觉感怀领悟。如今，豌豆大小的的绿果子依旧缀满枝头，格外丰硕繁盛，可是曾经呵护过它们的主人却都不在了，抽丝剥茧般地一下子抽离了偌大院子里的最后一丝人气。摘几颗放在嘴里，很酸很涩．不知道到这个夏天也要溜掉的时候，还会存留多少果子在摇曳依旧的枝头，大概也没人会在意了吧．</p>\n<p>有一年，这棵树的一个枝桠死掉了，爷爷一把板斧把它砍了去，整棵树才幸免于难活到现在，长得愈发健壮。如今，它竟成了这座孤零零院子里的主人，阳光透过大片的叶子落在地上，变得斑驳摇曳，跳动的光影里勾连起关于这座院子数不尽的斑驳的记忆。</p>\n<p>终于到了和本科生活道别的时候，也很快要和一大批小伙伴说再见了．爷爷奶奶生于斯长于斯葬于斯的黄土地，那里我残留的童年，流逝的过往，若和他们有一线牵连，也是要一并再见了的．可是我还有新的一段路要接着走下去．</p>\n","excerpt":"","more":"<p>今天是5月26号，周二，刚刚交掉毕业论文还不久。也恰好在一周之前，我从家里返回南京，走出站口，静默立在玄武湖畔，浸润着空气中氤氲着的大团湿气，不远处的紫峰大厦在雾霭里若隐若现，偌大的城市里，无边际的渺小感无力感纷至袭来，我竟会分外失落。</p>\n<p>回家是送奶奶走最后一程的。尽管在我们的民族里，死亡永远是一种禁忌，所有涉及到生死的话题都应该是沉痛的．但是回去之前，我还是给自己找了一千个不要哭出来的理由。可是真等到诀别那天，老人颤颤巍巍的样子终于隐隐约约出现在眼前，念想最后几年健在的时候，每次回去临走时，爷爷奶奶站在车门口流连不舍的情形，光影交错，恍若昨日，我一头扎进记忆的堆里拔不出来，防御的墙被连根拔起，彻底摧毁，哭得稀里哗啦。对孱弱生命的敬畏，就像面对无边暗夜里风中摇曳的残烛，你知道它很快会灭，可是总想，光明总是好的，还是灭得晚些罢。</p>\n<p>老家院子里有一颗杏树，许多年之前，爷爷奶奶都在的那些夏天，他们总是细心照看着来来往往的路人，想要把最好吃的大黄杏留给他们的儿孙。大家都在外边奔波忙碌，一年到头回去的次数很少，所以这种细微的感情从未被悉心察觉感怀领悟。如今，豌豆大小的的绿果子依旧缀满枝头，格外丰硕繁盛，可是曾经呵护过它们的主人却都不在了，抽丝剥茧般地一下子抽离了偌大院子里的最后一丝人气。摘几颗放在嘴里，很酸很涩．不知道到这个夏天也要溜掉的时候，还会存留多少果子在摇曳依旧的枝头，大概也没人会在意了吧．</p>\n<p>有一年，这棵树的一个枝桠死掉了，爷爷一把板斧把它砍了去，整棵树才幸免于难活到现在，长得愈发健壮。如今，它竟成了这座孤零零院子里的主人，阳光透过大片的叶子落在地上，变得斑驳摇曳，跳动的光影里勾连起关于这座院子数不尽的斑驳的记忆。</p>\n<p>终于到了和本科生活道别的时候，也很快要和一大批小伙伴说再见了．爷爷奶奶生于斯长于斯葬于斯的黄土地，那里我残留的童年，流逝的过往，若和他们有一线牵连，也是要一并再见了的．可是我还有新的一段路要接着走下去．</p>\n"},{"title":"linux搭建简单的vpn server","date":"2015-07-24T00:00:00.000Z","_content":"\n这几天跑实验，内网服务器想连外网，于是就想到在自己电脑搭一个vpn server来搞。今天折腾大半天搞定了，这里简单记录下操作步骤。\n\n1.使用pptpd,所以先安装:\n\n    sudo apt-get install pptpd\n\n修改**/etc/pptpd.conf**这个文件:\n\n找到以下俩行：\n\n    #localip 192.168.0.1\n    #remoteip 192.168.0.234-238,192.168.0.245\n\n把前面的#号去掉，然后保存就行了。这里，localip 是 VPN 链接成功后服务器的 ip 地址， 最后会是是你客户端的网关,remoteip 则客户端的可分配 ip 地址范围.最大连接数有默认限制,不过可以修改.其实随便在可用内网ip范围改啦：\n\n* --10.0.0.0/8：10.0.0.0～10.255.255.255 \n* --172.16.0.0/12：172.16.0.0～172.31.255.255 \n* --192.168.0.0/16：192.168.0.0～192.168.255.255\n\n编辑**/etc/ppp/pptpd-options**这个文件,为VPN指定DNS服务器，找到ms-dns这项，去掉前面的#号，修改成google提供的DNS\n\n    ms-dns 8.8.8.8\n    ms-dns 8.8.4.4\n    \n这是google的公开DNS ip,不过后来发现部分国内网站的解析会有问题,所以最后换成了ali的,这个问题就解决了.我把它归因于GFW，修改好后保存。\n\n- - - -\n\n接下来建立VPN账号和密码了，修改**/etc/ppp/chap-secrets**文件，按一行四列添加：\n\n* 账号\n* 服务器名 \n* 密码\n* IP\n\n即第一行是用户名，第二行是服务器名（默认写pptpd 即可，注意与 pptpd-options 文件保持一致,要改的话俩个地方都要改保持一致,不过没有意义），第三行是密码，第四列是 IP 限制（不做限制用 * ）。如创建一个名为test，密码为123，不限制登录IP的VPN账号：\n\n    mzs pptpd 123 *\n     \n多个账号另起一行就可以了.如果限制登陆地点,可以修改*处另作文章。重启：\n\n    service pptpd restart\n    service pppd-dns restart\n\n此时就可以用一个vpn客户端来登陆了,不过**还不能连外网**。\n修改**/etc/sysctl.conf**这个文件，把ipv4 forward开启，方法是找到**/etc/sysctl.conf**这个文件里的这一行：\n\n    #net.ipv4.ip_forward=1\n    \n去掉前面的#号，使之生效，然后保存，运行命令sysctl –p。如果显示：\n    \n    net.ipv4.ip_forward = 1\n\n这样初步搭完了,但是不能连外网,我在这个坑里跳了很久，要继续操作.\n\n- - - -\n\n**下边这边部分不是很懂，今天还没来得及研究，日后有理解补上来，**\n**弄懂了，补上来，将要从eth0出去的包，来源Ip，也就是从内网来的数据包，都替换成vpn server的public ip，这边是所谓的NAT，postrouting修改来源ip，prerouting则修改目的ip，一个是SNAT，一个是DNAT** \n\n设置iptables规则\n首先配置nat表的翻译规则, 将目标IP为192.168.0.0/24的包转向eth0接口. 在iptables配置文件的nat表中添加如下规则,指令:(如果有需要,先安装iptables)\n\n    iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE\n\nOK，到了这一步就应该可以用VPN了。如果不能，我也不知是哪里出问题了。\n如果要防止重启服务器后iptables丢失，先运行：\n\n    iptables-save > /etc/iptables-rules\n\n然后修改**/etc/network/interfaces**文件，在eth0 下面加入：\n\n    pre-up iptables-restore < /etc/iptables-rules\n这样，服务器重启后，就能自动挂载规则了。可以考虑租个服务器卖翻墙vpn了。\n\n- - - -\n","source":"_posts/2015-07-24#linux搭建简单的vpn server.md","raw":"---\ntitle: linux搭建简单的vpn server\npermalink: vpn-server\ntags:\n    - vpn server\n    - linux\ndate: 2015-07-24 \n---\n\n这几天跑实验，内网服务器想连外网，于是就想到在自己电脑搭一个vpn server来搞。今天折腾大半天搞定了，这里简单记录下操作步骤。\n\n1.使用pptpd,所以先安装:\n\n    sudo apt-get install pptpd\n\n修改**/etc/pptpd.conf**这个文件:\n\n找到以下俩行：\n\n    #localip 192.168.0.1\n    #remoteip 192.168.0.234-238,192.168.0.245\n\n把前面的#号去掉，然后保存就行了。这里，localip 是 VPN 链接成功后服务器的 ip 地址， 最后会是是你客户端的网关,remoteip 则客户端的可分配 ip 地址范围.最大连接数有默认限制,不过可以修改.其实随便在可用内网ip范围改啦：\n\n* --10.0.0.0/8：10.0.0.0～10.255.255.255 \n* --172.16.0.0/12：172.16.0.0～172.31.255.255 \n* --192.168.0.0/16：192.168.0.0～192.168.255.255\n\n编辑**/etc/ppp/pptpd-options**这个文件,为VPN指定DNS服务器，找到ms-dns这项，去掉前面的#号，修改成google提供的DNS\n\n    ms-dns 8.8.8.8\n    ms-dns 8.8.4.4\n    \n这是google的公开DNS ip,不过后来发现部分国内网站的解析会有问题,所以最后换成了ali的,这个问题就解决了.我把它归因于GFW，修改好后保存。\n\n- - - -\n\n接下来建立VPN账号和密码了，修改**/etc/ppp/chap-secrets**文件，按一行四列添加：\n\n* 账号\n* 服务器名 \n* 密码\n* IP\n\n即第一行是用户名，第二行是服务器名（默认写pptpd 即可，注意与 pptpd-options 文件保持一致,要改的话俩个地方都要改保持一致,不过没有意义），第三行是密码，第四列是 IP 限制（不做限制用 * ）。如创建一个名为test，密码为123，不限制登录IP的VPN账号：\n\n    mzs pptpd 123 *\n     \n多个账号另起一行就可以了.如果限制登陆地点,可以修改*处另作文章。重启：\n\n    service pptpd restart\n    service pppd-dns restart\n\n此时就可以用一个vpn客户端来登陆了,不过**还不能连外网**。\n修改**/etc/sysctl.conf**这个文件，把ipv4 forward开启，方法是找到**/etc/sysctl.conf**这个文件里的这一行：\n\n    #net.ipv4.ip_forward=1\n    \n去掉前面的#号，使之生效，然后保存，运行命令sysctl –p。如果显示：\n    \n    net.ipv4.ip_forward = 1\n\n这样初步搭完了,但是不能连外网,我在这个坑里跳了很久，要继续操作.\n\n- - - -\n\n**下边这边部分不是很懂，今天还没来得及研究，日后有理解补上来，**\n**弄懂了，补上来，将要从eth0出去的包，来源Ip，也就是从内网来的数据包，都替换成vpn server的public ip，这边是所谓的NAT，postrouting修改来源ip，prerouting则修改目的ip，一个是SNAT，一个是DNAT** \n\n设置iptables规则\n首先配置nat表的翻译规则, 将目标IP为192.168.0.0/24的包转向eth0接口. 在iptables配置文件的nat表中添加如下规则,指令:(如果有需要,先安装iptables)\n\n    iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE\n\nOK，到了这一步就应该可以用VPN了。如果不能，我也不知是哪里出问题了。\n如果要防止重启服务器后iptables丢失，先运行：\n\n    iptables-save > /etc/iptables-rules\n\n然后修改**/etc/network/interfaces**文件，在eth0 下面加入：\n\n    pre-up iptables-restore < /etc/iptables-rules\n这样，服务器重启后，就能自动挂载规则了。可以考虑租个服务器卖翻墙vpn了。\n\n- - - -\n","slug":"vpn-server","published":1,"updated":"2016-03-16T07:45:18.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimba54va000506omaps9jjnm","content":"<p>这几天跑实验，内网服务器想连外网，于是就想到在自己电脑搭一个vpn server来搞。今天折腾大半天搞定了，这里简单记录下操作步骤。</p>\n<p>1.使用pptpd,所以先安装:</p>\n<pre><code>sudo apt-get install pptpd\n</code></pre><p>修改<strong>/etc/pptpd.conf</strong>这个文件:</p>\n<p>找到以下俩行：</p>\n<pre><code>#localip 192.168.0.1\n#remoteip 192.168.0.234-238,192.168.0.245\n</code></pre><p>把前面的#号去掉，然后保存就行了。这里，localip 是 VPN 链接成功后服务器的 ip 地址， 最后会是是你客户端的网关,remoteip 则客户端的可分配 ip 地址范围.最大连接数有默认限制,不过可以修改.其实随便在可用内网ip范围改啦：</p>\n<ul>\n<li>–10.0.0.0/8：10.0.0.0～10.255.255.255 </li>\n<li>–172.16.0.0/12：172.16.0.0～172.31.255.255 </li>\n<li>–192.168.0.0/16：192.168.0.0～192.168.255.255</li>\n</ul>\n<p>编辑<strong>/etc/ppp/pptpd-options</strong>这个文件,为VPN指定DNS服务器，找到ms-dns这项，去掉前面的#号，修改成google提供的DNS</p>\n<pre><code>ms-dns 8.8.8.8\nms-dns 8.8.4.4\n</code></pre><p>这是google的公开DNS ip,不过后来发现部分国内网站的解析会有问题,所以最后换成了ali的,这个问题就解决了.我把它归因于GFW，修改好后保存。</p>\n<hr>\n<p>接下来建立VPN账号和密码了，修改<strong>/etc/ppp/chap-secrets</strong>文件，按一行四列添加：</p>\n<ul>\n<li>账号</li>\n<li>服务器名 </li>\n<li>密码</li>\n<li>IP</li>\n</ul>\n<p>即第一行是用户名，第二行是服务器名（默认写pptpd 即可，注意与 pptpd-options 文件保持一致,要改的话俩个地方都要改保持一致,不过没有意义），第三行是密码，第四列是 IP 限制（不做限制用 * ）。如创建一个名为test，密码为123，不限制登录IP的VPN账号：</p>\n<pre><code>mzs pptpd 123 *\n</code></pre><p>多个账号另起一行就可以了.如果限制登陆地点,可以修改*处另作文章。重启：</p>\n<pre><code>service pptpd restart\nservice pppd-dns restart\n</code></pre><p>此时就可以用一个vpn客户端来登陆了,不过<strong>还不能连外网</strong>。<br>修改<strong>/etc/sysctl.conf</strong>这个文件，把ipv4 forward开启，方法是找到<strong>/etc/sysctl.conf</strong>这个文件里的这一行：</p>\n<pre><code>#net.ipv4.ip_forward=1\n</code></pre><p>去掉前面的#号，使之生效，然后保存，运行命令sysctl –p。如果显示：</p>\n<pre><code>net.ipv4.ip_forward = 1\n</code></pre><p>这样初步搭完了,但是不能连外网,我在这个坑里跳了很久，要继续操作.</p>\n<hr>\n<p><strong>下边这边部分不是很懂，今天还没来得及研究，日后有理解补上来，</strong><br><strong>弄懂了，补上来，将要从eth0出去的包，来源Ip，也就是从内网来的数据包，都替换成vpn server的public ip，这边是所谓的NAT，postrouting修改来源ip，prerouting则修改目的ip，一个是SNAT，一个是DNAT</strong> </p>\n<p>设置iptables规则<br>首先配置nat表的翻译规则, 将目标IP为192.168.0.0/24的包转向eth0接口. 在iptables配置文件的nat表中添加如下规则,指令:(如果有需要,先安装iptables)</p>\n<pre><code>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE\n</code></pre><p>OK，到了这一步就应该可以用VPN了。如果不能，我也不知是哪里出问题了。<br>如果要防止重启服务器后iptables丢失，先运行：</p>\n<pre><code>iptables-save &gt; /etc/iptables-rules\n</code></pre><p>然后修改<strong>/etc/network/interfaces</strong>文件，在eth0 下面加入：</p>\n<pre><code>pre-up iptables-restore &lt; /etc/iptables-rules\n</code></pre><p>这样，服务器重启后，就能自动挂载规则了。可以考虑租个服务器卖翻墙vpn了。</p>\n<hr>\n","excerpt":"","more":"<p>这几天跑实验，内网服务器想连外网，于是就想到在自己电脑搭一个vpn server来搞。今天折腾大半天搞定了，这里简单记录下操作步骤。</p>\n<p>1.使用pptpd,所以先安装:</p>\n<pre><code>sudo apt-get install pptpd\n</code></pre><p>修改<strong>/etc/pptpd.conf</strong>这个文件:</p>\n<p>找到以下俩行：</p>\n<pre><code>#localip 192.168.0.1\n#remoteip 192.168.0.234-238,192.168.0.245\n</code></pre><p>把前面的#号去掉，然后保存就行了。这里，localip 是 VPN 链接成功后服务器的 ip 地址， 最后会是是你客户端的网关,remoteip 则客户端的可分配 ip 地址范围.最大连接数有默认限制,不过可以修改.其实随便在可用内网ip范围改啦：</p>\n<ul>\n<li>–10.0.0.0/8：10.0.0.0～10.255.255.255 </li>\n<li>–172.16.0.0/12：172.16.0.0～172.31.255.255 </li>\n<li>–192.168.0.0/16：192.168.0.0～192.168.255.255</li>\n</ul>\n<p>编辑<strong>/etc/ppp/pptpd-options</strong>这个文件,为VPN指定DNS服务器，找到ms-dns这项，去掉前面的#号，修改成google提供的DNS</p>\n<pre><code>ms-dns 8.8.8.8\nms-dns 8.8.4.4\n</code></pre><p>这是google的公开DNS ip,不过后来发现部分国内网站的解析会有问题,所以最后换成了ali的,这个问题就解决了.我把它归因于GFW，修改好后保存。</p>\n<hr>\n<p>接下来建立VPN账号和密码了，修改<strong>/etc/ppp/chap-secrets</strong>文件，按一行四列添加：</p>\n<ul>\n<li>账号</li>\n<li>服务器名 </li>\n<li>密码</li>\n<li>IP</li>\n</ul>\n<p>即第一行是用户名，第二行是服务器名（默认写pptpd 即可，注意与 pptpd-options 文件保持一致,要改的话俩个地方都要改保持一致,不过没有意义），第三行是密码，第四列是 IP 限制（不做限制用 * ）。如创建一个名为test，密码为123，不限制登录IP的VPN账号：</p>\n<pre><code>mzs pptpd 123 *\n</code></pre><p>多个账号另起一行就可以了.如果限制登陆地点,可以修改*处另作文章。重启：</p>\n<pre><code>service pptpd restart\nservice pppd-dns restart\n</code></pre><p>此时就可以用一个vpn客户端来登陆了,不过<strong>还不能连外网</strong>。<br>修改<strong>/etc/sysctl.conf</strong>这个文件，把ipv4 forward开启，方法是找到<strong>/etc/sysctl.conf</strong>这个文件里的这一行：</p>\n<pre><code>#net.ipv4.ip_forward=1\n</code></pre><p>去掉前面的#号，使之生效，然后保存，运行命令sysctl –p。如果显示：</p>\n<pre><code>net.ipv4.ip_forward = 1\n</code></pre><p>这样初步搭完了,但是不能连外网,我在这个坑里跳了很久，要继续操作.</p>\n<hr>\n<p><strong>下边这边部分不是很懂，今天还没来得及研究，日后有理解补上来，</strong><br><strong>弄懂了，补上来，将要从eth0出去的包，来源Ip，也就是从内网来的数据包，都替换成vpn server的public ip，这边是所谓的NAT，postrouting修改来源ip，prerouting则修改目的ip，一个是SNAT，一个是DNAT</strong> </p>\n<p>设置iptables规则<br>首先配置nat表的翻译规则, 将目标IP为192.168.0.0/24的包转向eth0接口. 在iptables配置文件的nat表中添加如下规则,指令:(如果有需要,先安装iptables)</p>\n<pre><code>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE\n</code></pre><p>OK，到了这一步就应该可以用VPN了。如果不能，我也不知是哪里出问题了。<br>如果要防止重启服务器后iptables丢失，先运行：</p>\n<pre><code>iptables-save &gt; /etc/iptables-rules\n</code></pre><p>然后修改<strong>/etc/network/interfaces</strong>文件，在eth0 下面加入：</p>\n<pre><code>pre-up iptables-restore &lt; /etc/iptables-rules\n</code></pre><p>这样，服务器重启后，就能自动挂载规则了。可以考虑租个服务器卖翻墙vpn了。</p>\n<hr>\n"},{"title":"用nginx反向代理docker来代替publish端口","date":"2016-02-25T00:00:00.000Z","_content":"\n我们知道docker默认是可以访问外网的，这是由于网桥(默认网桥是虚拟出来的docker0)的存在，而如果想从外网访问docker容器应用，一般的做法是启动docker时用publish作端口映射，其实俩种做法本质上都是修改了本地的iptables NAT规则，所以即使不用显示地publish，直接修改本机的iptables规则应该就可以实现这个功能，但是我还太菜搞不来。[端口映射会有一些问题](https://www.ttlsa.com/nginx/use-nginx-proxy/)。所以可以用nginx作反向代理替代之。\n\n反向代理和正向代理的区别具体可以自行google。泛化的理解就是区网的主机访问外网要用正向代理，而外网访问区网的则某台主机是要通过反向代理的。所以一般的VPN属于正向代理，好，言归正传。\n\n我的网络拓扑是这样的:\n\n- 一台pc主机,静态ip为A,是公网ip.\n- pc上运行一个[gitlab docker](https://github.com/sameersbn/docker-gitlab)，该容器ip为B，是内网ip，已经在build image时expose 80端口。\n\n我的目标是在任意主机浏览器输入A(或者绑定到A的域名),能够访问到该gitlab.\n\nnginx的安装ubuntu下可用apt轻松搞定,配置文件目录在**/etc/nginx/**，不得不说，[nginx配置文件结构极其简单](https://www.digitalocean.com/community/tutorials/understanding-the-nginx-configuration-file-structure-and-configuration-contexts)，之前研究过nagios和apache的配置文件，都比nginx要复杂些。配置文件主要为**nginx.conf**。\n\n该文件分成四个部分：\n\n-  main（全局设置）\n-  server（主机设置）\n-  upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）\n- location（URL匹配特定位置后的设置），每部分包含若干个指令\n\nmain部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。具体的区别同样可以google之,其他的配置文件不是必须的,或者说是可以自己在**nginx.conf**中指定和调整的,因此在nginx中,nginx.conf这个文件是最重要的。\n\n因此一个主机对应一个server对象,server的定义可以放在任何文件中,只要在**nginx.conf**中正确位置include进来就可以了,比如我在**/etc/nginx/**目录下随便新建mzs.conf，文件内容:\n\n    server\n    {\n    listen 80; #也可以添加要监听的ip地址，格式为ip:port\n    server_name A; #这个server name是包含在request包头部的，就是用户在浏览器输入的地址，不是本地！\n    location / {\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass http://B:80;    #反向代理到docker B:80\n    }\n    }\n\n在nginx.conf中修改:\n\n    # Virtual Host Configs\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n    include /etc/nginx/mzs.conf;  #添加了这一行就可以了.\n    \n添加这一行的目的是把server的配置include进来,因此也可以直接在nginx.conf文件对应位置放置mzs.conf的内容，\n另一种配置方式(同样在*nginx.conf*中)，设定负载均衡后台服务器列表,可以是多个 :\n\n    upstream  backend  { \n              server   B:80 max_fails=2 fail_timeout=30s ;  \n              #server   192.168.10.101:8080 max_fails=2 fail_timeout=30s ;  \n    }\n    server {\n        listen       80;\n        server_name  A;\n        #对 / 所有做负载均衡+反向代理\n        location / {\n            root   /apps/oaapp;\n            index  index.jsp index.html index.htm;\n\t\t\t#请求转向backend定义的服务器列表，即反向代理，对应upstream负载均衡器。也可以proxy_pass http://ip:port\n            proxy_pass        http://backend;   \n            proxy_redirect off;\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header  Host  $host;\n            proxy_set_header  X-Real-IP  $remote_addr;  \n            proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;\n            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n        }\n        \n即把docker的ip:port配置在upstream中,这样如果一个域名指向多个ip的server,就可以实现负载均衡,proxy_pass的时候再对应负载均衡器的名字就可以了.比如google,每次访问请求到达后台哪个服务器,大概也是这样的实现原理.\n最后root权限运行:\n\n    service nginx reload\n    serivce nginx restart\n    \n搞定，当然也可以把nginx放在docker容器中。另外，所谓的端口映射其实就是一种iptables的DNAT过程而已。\n\n## 参考:\n\n1. [nginx做负载均衡器以及proxy缓存配置](http://seanlook.com/2015/06/02/nginx-cache-check/)\n2. [Nginx配置文件nginx.conf中文详解](http://www.ha97.com/5194.html)\n3. [nginx服务器安装及配置文件详解](https://segmentfault.com/a/1190000002797601)\n4. [Automated Nginx Reverse Proxy for Docker](http://jasonwilder.com/blog/2014/03/25/automated-nginx-reverse-proxy-for-docker/)\n","source":"_posts/2016-02-25#用nginx反向代理docker来代替publish端口.md","raw":"---\ntitle: 用nginx反向代理docker来代替publish端口\npermalink: nginx-docker\ntags:\n    - nginx\n    - docker\ndate: 2016-02-25\n---\n\n我们知道docker默认是可以访问外网的，这是由于网桥(默认网桥是虚拟出来的docker0)的存在，而如果想从外网访问docker容器应用，一般的做法是启动docker时用publish作端口映射，其实俩种做法本质上都是修改了本地的iptables NAT规则，所以即使不用显示地publish，直接修改本机的iptables规则应该就可以实现这个功能，但是我还太菜搞不来。[端口映射会有一些问题](https://www.ttlsa.com/nginx/use-nginx-proxy/)。所以可以用nginx作反向代理替代之。\n\n反向代理和正向代理的区别具体可以自行google。泛化的理解就是区网的主机访问外网要用正向代理，而外网访问区网的则某台主机是要通过反向代理的。所以一般的VPN属于正向代理，好，言归正传。\n\n我的网络拓扑是这样的:\n\n- 一台pc主机,静态ip为A,是公网ip.\n- pc上运行一个[gitlab docker](https://github.com/sameersbn/docker-gitlab)，该容器ip为B，是内网ip，已经在build image时expose 80端口。\n\n我的目标是在任意主机浏览器输入A(或者绑定到A的域名),能够访问到该gitlab.\n\nnginx的安装ubuntu下可用apt轻松搞定,配置文件目录在**/etc/nginx/**，不得不说，[nginx配置文件结构极其简单](https://www.digitalocean.com/community/tutorials/understanding-the-nginx-configuration-file-structure-and-configuration-contexts)，之前研究过nagios和apache的配置文件，都比nginx要复杂些。配置文件主要为**nginx.conf**。\n\n该文件分成四个部分：\n\n-  main（全局设置）\n-  server（主机设置）\n-  upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）\n- location（URL匹配特定位置后的设置），每部分包含若干个指令\n\nmain部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。具体的区别同样可以google之,其他的配置文件不是必须的,或者说是可以自己在**nginx.conf**中指定和调整的,因此在nginx中,nginx.conf这个文件是最重要的。\n\n因此一个主机对应一个server对象,server的定义可以放在任何文件中,只要在**nginx.conf**中正确位置include进来就可以了,比如我在**/etc/nginx/**目录下随便新建mzs.conf，文件内容:\n\n    server\n    {\n    listen 80; #也可以添加要监听的ip地址，格式为ip:port\n    server_name A; #这个server name是包含在request包头部的，就是用户在浏览器输入的地址，不是本地！\n    location / {\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass http://B:80;    #反向代理到docker B:80\n    }\n    }\n\n在nginx.conf中修改:\n\n    # Virtual Host Configs\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n    include /etc/nginx/mzs.conf;  #添加了这一行就可以了.\n    \n添加这一行的目的是把server的配置include进来,因此也可以直接在nginx.conf文件对应位置放置mzs.conf的内容，\n另一种配置方式(同样在*nginx.conf*中)，设定负载均衡后台服务器列表,可以是多个 :\n\n    upstream  backend  { \n              server   B:80 max_fails=2 fail_timeout=30s ;  \n              #server   192.168.10.101:8080 max_fails=2 fail_timeout=30s ;  \n    }\n    server {\n        listen       80;\n        server_name  A;\n        #对 / 所有做负载均衡+反向代理\n        location / {\n            root   /apps/oaapp;\n            index  index.jsp index.html index.htm;\n\t\t\t#请求转向backend定义的服务器列表，即反向代理，对应upstream负载均衡器。也可以proxy_pass http://ip:port\n            proxy_pass        http://backend;   \n            proxy_redirect off;\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header  Host  $host;\n            proxy_set_header  X-Real-IP  $remote_addr;  \n            proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;\n            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n        }\n        \n即把docker的ip:port配置在upstream中,这样如果一个域名指向多个ip的server,就可以实现负载均衡,proxy_pass的时候再对应负载均衡器的名字就可以了.比如google,每次访问请求到达后台哪个服务器,大概也是这样的实现原理.\n最后root权限运行:\n\n    service nginx reload\n    serivce nginx restart\n    \n搞定，当然也可以把nginx放在docker容器中。另外，所谓的端口映射其实就是一种iptables的DNAT过程而已。\n\n## 参考:\n\n1. [nginx做负载均衡器以及proxy缓存配置](http://seanlook.com/2015/06/02/nginx-cache-check/)\n2. [Nginx配置文件nginx.conf中文详解](http://www.ha97.com/5194.html)\n3. [nginx服务器安装及配置文件详解](https://segmentfault.com/a/1190000002797601)\n4. [Automated Nginx Reverse Proxy for Docker](http://jasonwilder.com/blog/2014/03/25/automated-nginx-reverse-proxy-for-docker/)\n","slug":"nginx-docker","published":1,"updated":"2016-03-28T01:23:03.558Z","_id":"cimba54vh000706omqlnjhdzz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我们知道docker默认是可以访问外网的，这是由于网桥(默认网桥是虚拟出来的docker0)的存在，而如果想从外网访问docker容器应用，一般的做法是启动docker时用publish作端口映射，其实俩种做法本质上都是修改了本地的iptables NAT规则，所以即使不用显示地publish，直接修改本机的iptables规则应该就可以实现这个功能，但是我还太菜搞不来。<a href=\"https://www.ttlsa.com/nginx/use-nginx-proxy/\" target=\"_blank\" rel=\"external\">端口映射会有一些问题</a>。所以可以用nginx作反向代理替代之。</p>\n<p>反向代理和正向代理的区别具体可以自行google。泛化的理解就是区网的主机访问外网要用正向代理，而外网访问区网的则某台主机是要通过反向代理的。所以一般的VPN属于正向代理，好，言归正传。</p>\n<p>我的网络拓扑是这样的:</p>\n<ul>\n<li>一台pc主机,静态ip为A,是公网ip.</li>\n<li>pc上运行一个<a href=\"https://github.com/sameersbn/docker-gitlab\" target=\"_blank\" rel=\"external\">gitlab docker</a>，该容器ip为B，是内网ip，已经在build image时expose 80端口。</li>\n</ul>\n<p>我的目标是在任意主机浏览器输入A(或者绑定到A的域名),能够访问到该gitlab.</p>\n<p>nginx的安装ubuntu下可用apt轻松搞定,配置文件目录在<strong>/etc/nginx/</strong>，不得不说，<a href=\"https://www.digitalocean.com/community/tutorials/understanding-the-nginx-configuration-file-structure-and-configuration-contexts\" target=\"_blank\" rel=\"external\">nginx配置文件结构极其简单</a>，之前研究过nagios和apache的配置文件，都比nginx要复杂些。配置文件主要为<strong>nginx.conf</strong>。</p>\n<p>该文件分成四个部分：</p>\n<ul>\n<li>main（全局设置）</li>\n<li>server（主机设置）</li>\n<li>upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）</li>\n<li>location（URL匹配特定位置后的设置），每部分包含若干个指令</li>\n</ul>\n<p>main部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。具体的区别同样可以google之,其他的配置文件不是必须的,或者说是可以自己在<strong>nginx.conf</strong>中指定和调整的,因此在nginx中,nginx.conf这个文件是最重要的。</p>\n<p>因此一个主机对应一个server对象,server的定义可以放在任何文件中,只要在<strong>nginx.conf</strong>中正确位置include进来就可以了,比如我在<strong>/etc/nginx/</strong>目录下随便新建mzs.conf，文件内容:</p>\n<pre><code>server\n{\nlisten 80; #也可以添加要监听的ip地址，格式为ip:port\nserver_name A; #这个server name是包含在request包头部的，就是用户在浏览器输入的地址，不是本地！\nlocation / {\n    proxy_redirect off;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_pass http://B:80;    #反向代理到docker B:80\n}\n}\n</code></pre><p>在nginx.conf中修改:</p>\n<pre><code># Virtual Host Configs\ninclude /etc/nginx/conf.d/*.conf;\ninclude /etc/nginx/sites-enabled/*;\ninclude /etc/nginx/mzs.conf;  #添加了这一行就可以了.\n</code></pre><p>添加这一行的目的是把server的配置include进来,因此也可以直接在nginx.conf文件对应位置放置mzs.conf的内容，<br>另一种配置方式(同样在<em>nginx.conf</em>中)，设定负载均衡后台服务器列表,可以是多个 :</p>\n<pre><code>upstream  backend  { \n          server   B:80 max_fails=2 fail_timeout=30s ;  \n          #server   192.168.10.101:8080 max_fails=2 fail_timeout=30s ;  \n}\nserver {\n    listen       80;\n    server_name  A;\n    #对 / 所有做负载均衡+反向代理\n    location / {\n        root   /apps/oaapp;\n        index  index.jsp index.html index.htm;\n        #请求转向backend定义的服务器列表，即反向代理，对应upstream负载均衡器。也可以proxy_pass http://ip:port\n        proxy_pass        http://backend;   \n        proxy_redirect off;\n        #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n        proxy_set_header  Host  $host;\n        proxy_set_header  X-Real-IP  $remote_addr;  \n        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;\n        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n    }\n</code></pre><p>即把docker的ip:port配置在upstream中,这样如果一个域名指向多个ip的server,就可以实现负载均衡,proxy_pass的时候再对应负载均衡器的名字就可以了.比如google,每次访问请求到达后台哪个服务器,大概也是这样的实现原理.<br>最后root权限运行:</p>\n<pre><code>service nginx reload\nserivce nginx restart\n</code></pre><p>搞定，当然也可以把nginx放在docker容器中。另外，所谓的端口映射其实就是一种iptables的DNAT过程而已。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h2><ol>\n<li><a href=\"http://seanlook.com/2015/06/02/nginx-cache-check/\" target=\"_blank\" rel=\"external\">nginx做负载均衡器以及proxy缓存配置</a></li>\n<li><a href=\"http://www.ha97.com/5194.html\" target=\"_blank\" rel=\"external\">Nginx配置文件nginx.conf中文详解</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000002797601\" target=\"_blank\" rel=\"external\">nginx服务器安装及配置文件详解</a></li>\n<li><a href=\"http://jasonwilder.com/blog/2014/03/25/automated-nginx-reverse-proxy-for-docker/\" target=\"_blank\" rel=\"external\">Automated Nginx Reverse Proxy for Docker</a></li>\n</ol>\n","excerpt":"","more":"<p>我们知道docker默认是可以访问外网的，这是由于网桥(默认网桥是虚拟出来的docker0)的存在，而如果想从外网访问docker容器应用，一般的做法是启动docker时用publish作端口映射，其实俩种做法本质上都是修改了本地的iptables NAT规则，所以即使不用显示地publish，直接修改本机的iptables规则应该就可以实现这个功能，但是我还太菜搞不来。<a href=\"https://www.ttlsa.com/nginx/use-nginx-proxy/\">端口映射会有一些问题</a>。所以可以用nginx作反向代理替代之。</p>\n<p>反向代理和正向代理的区别具体可以自行google。泛化的理解就是区网的主机访问外网要用正向代理，而外网访问区网的则某台主机是要通过反向代理的。所以一般的VPN属于正向代理，好，言归正传。</p>\n<p>我的网络拓扑是这样的:</p>\n<ul>\n<li>一台pc主机,静态ip为A,是公网ip.</li>\n<li>pc上运行一个<a href=\"https://github.com/sameersbn/docker-gitlab\">gitlab docker</a>，该容器ip为B，是内网ip，已经在build image时expose 80端口。</li>\n</ul>\n<p>我的目标是在任意主机浏览器输入A(或者绑定到A的域名),能够访问到该gitlab.</p>\n<p>nginx的安装ubuntu下可用apt轻松搞定,配置文件目录在<strong>/etc/nginx/</strong>，不得不说，<a href=\"https://www.digitalocean.com/community/tutorials/understanding-the-nginx-configuration-file-structure-and-configuration-contexts\">nginx配置文件结构极其简单</a>，之前研究过nagios和apache的配置文件，都比nginx要复杂些。配置文件主要为<strong>nginx.conf</strong>。</p>\n<p>该文件分成四个部分：</p>\n<ul>\n<li>main（全局设置）</li>\n<li>server（主机设置）</li>\n<li>upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）</li>\n<li>location（URL匹配特定位置后的设置），每部分包含若干个指令</li>\n</ul>\n<p>main部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。具体的区别同样可以google之,其他的配置文件不是必须的,或者说是可以自己在<strong>nginx.conf</strong>中指定和调整的,因此在nginx中,nginx.conf这个文件是最重要的。</p>\n<p>因此一个主机对应一个server对象,server的定义可以放在任何文件中,只要在<strong>nginx.conf</strong>中正确位置include进来就可以了,比如我在<strong>/etc/nginx/</strong>目录下随便新建mzs.conf，文件内容:</p>\n<pre><code>server\n{\nlisten 80; #也可以添加要监听的ip地址，格式为ip:port\nserver_name A; #这个server name是包含在request包头部的，就是用户在浏览器输入的地址，不是本地！\nlocation / {\n    proxy_redirect off;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_pass http://B:80;    #反向代理到docker B:80\n}\n}\n</code></pre><p>在nginx.conf中修改:</p>\n<pre><code># Virtual Host Configs\ninclude /etc/nginx/conf.d/*.conf;\ninclude /etc/nginx/sites-enabled/*;\ninclude /etc/nginx/mzs.conf;  #添加了这一行就可以了.\n</code></pre><p>添加这一行的目的是把server的配置include进来,因此也可以直接在nginx.conf文件对应位置放置mzs.conf的内容，<br>另一种配置方式(同样在<em>nginx.conf</em>中)，设定负载均衡后台服务器列表,可以是多个 :</p>\n<pre><code>upstream  backend  { \n          server   B:80 max_fails=2 fail_timeout=30s ;  \n          #server   192.168.10.101:8080 max_fails=2 fail_timeout=30s ;  \n}\nserver {\n    listen       80;\n    server_name  A;\n    #对 / 所有做负载均衡+反向代理\n    location / {\n        root   /apps/oaapp;\n        index  index.jsp index.html index.htm;\n        #请求转向backend定义的服务器列表，即反向代理，对应upstream负载均衡器。也可以proxy_pass http://ip:port\n        proxy_pass        http://backend;   \n        proxy_redirect off;\n        #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n        proxy_set_header  Host  $host;\n        proxy_set_header  X-Real-IP  $remote_addr;  \n        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;\n        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n    }\n</code></pre><p>即把docker的ip:port配置在upstream中,这样如果一个域名指向多个ip的server,就可以实现负载均衡,proxy_pass的时候再对应负载均衡器的名字就可以了.比如google,每次访问请求到达后台哪个服务器,大概也是这样的实现原理.<br>最后root权限运行:</p>\n<pre><code>service nginx reload\nserivce nginx restart\n</code></pre><p>搞定，当然也可以把nginx放在docker容器中。另外，所谓的端口映射其实就是一种iptables的DNAT过程而已。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h2><ol>\n<li><a href=\"http://seanlook.com/2015/06/02/nginx-cache-check/\">nginx做负载均衡器以及proxy缓存配置</a></li>\n<li><a href=\"http://www.ha97.com/5194.html\">Nginx配置文件nginx.conf中文详解</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000002797601\">nginx服务器安装及配置文件详解</a></li>\n<li><a href=\"http://jasonwilder.com/blog/2014/03/25/automated-nginx-reverse-proxy-for-docker/\">Automated Nginx Reverse Proxy for Docker</a></li>\n</ol>\n"},{"title":"gitlab-docker更新指南","date":"2016-02-29T00:00:00.000Z","_content":"\n## 1. build新版本的gitlab的docker image文件 \n\n    cd ~/dockerimages/gitlab/no-nrpe;\n    \n修改Dockerfile中FROM指令gitlab为最新版本号,然后:\n\n    docker build -t docker.answ.me:5000/aplusplus/gitlab:8.5.1 .     #本次更新的版本号为8.5.1\n\nbuild过程时间会略长,之后会生成新的gitlab image文件，之后的过程都在/ICSapps/compose-file/ics目录下：\n\n    cd /ICSapps/compose-file/ics\n\n## 2. 接下来build数据库和redis(这一块不一定需要，因为redis和postgresql版本更新的很慢)\n\n    cd /ICSapps/compose-file/ics\n    docker-compose stop; #把三个进程都停掉\n\n然后pull 数据库和redis的image:\n\n    docker pull docker.answ.me:5000/aplusplus/redis\n    docker pull docker.answ.me:5000/aplusplus/postgresql:9.4-13  #新的版本号,要改\n    docker-compose up -d\n\n\n## 3. 备份数据(**如果无需更新redis和postgresql,可直接到这步**)\n\n先停掉gitlab:\n    \n    docker-compose stop gitlab\n    screen -S i\n\n修改**backup.sh**中的版本,然后运行该脚本,进行数据备份(修改为这次要备份的版本号),这个过程要花费一些时间\n\n## 4. 重新启动\n\n    docker-compose stop\n    docker-compose rm -vf #删除已经stop的container,container里边不存有数据,因为数据都在数据库和挂载到主机的目录里,因此可以放心删除之\n    vi docker-compose.yml #修改所有的版本号,三个软件的\n    docker-compose up -d\n\n最后更新完成,全程需要root权限。\n\n","source":"_posts/2016-02-29#gitlab-docker更新指南.md","raw":"---\ntitle: gitlab-docker更新指南\npermalink: igtlab-docker-update\ntags:\n    - gitlab\ndate: 2016-02-29\n---\n\n## 1. build新版本的gitlab的docker image文件 \n\n    cd ~/dockerimages/gitlab/no-nrpe;\n    \n修改Dockerfile中FROM指令gitlab为最新版本号,然后:\n\n    docker build -t docker.answ.me:5000/aplusplus/gitlab:8.5.1 .     #本次更新的版本号为8.5.1\n\nbuild过程时间会略长,之后会生成新的gitlab image文件，之后的过程都在/ICSapps/compose-file/ics目录下：\n\n    cd /ICSapps/compose-file/ics\n\n## 2. 接下来build数据库和redis(这一块不一定需要，因为redis和postgresql版本更新的很慢)\n\n    cd /ICSapps/compose-file/ics\n    docker-compose stop; #把三个进程都停掉\n\n然后pull 数据库和redis的image:\n\n    docker pull docker.answ.me:5000/aplusplus/redis\n    docker pull docker.answ.me:5000/aplusplus/postgresql:9.4-13  #新的版本号,要改\n    docker-compose up -d\n\n\n## 3. 备份数据(**如果无需更新redis和postgresql,可直接到这步**)\n\n先停掉gitlab:\n    \n    docker-compose stop gitlab\n    screen -S i\n\n修改**backup.sh**中的版本,然后运行该脚本,进行数据备份(修改为这次要备份的版本号),这个过程要花费一些时间\n\n## 4. 重新启动\n\n    docker-compose stop\n    docker-compose rm -vf #删除已经stop的container,container里边不存有数据,因为数据都在数据库和挂载到主机的目录里,因此可以放心删除之\n    vi docker-compose.yml #修改所有的版本号,三个软件的\n    docker-compose up -d\n\n最后更新完成,全程需要root权限。\n\n","slug":"igtlab-docker-update","published":1,"updated":"2016-03-09T05:53:46.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimba54vl000906om4brj9o72","content":"<h2 id=\"1-build新版本的gitlab的docker-image文件\"><a href=\"#1-build新版本的gitlab的docker-image文件\" class=\"headerlink\" title=\"1. build新版本的gitlab的docker image文件\"></a>1. build新版本的gitlab的docker image文件</h2><pre><code>cd ~/dockerimages/gitlab/no-nrpe;\n</code></pre><p>修改Dockerfile中FROM指令gitlab为最新版本号,然后:</p>\n<pre><code>docker build -t docker.answ.me:5000/aplusplus/gitlab:8.5.1 .     #本次更新的版本号为8.5.1\n</code></pre><p>build过程时间会略长,之后会生成新的gitlab image文件，之后的过程都在/ICSapps/compose-file/ics目录下：</p>\n<pre><code>cd /ICSapps/compose-file/ics\n</code></pre><h2 id=\"2-接下来build数据库和redis-这一块不一定需要，因为redis和postgresql版本更新的很慢\"><a href=\"#2-接下来build数据库和redis-这一块不一定需要，因为redis和postgresql版本更新的很慢\" class=\"headerlink\" title=\"2. 接下来build数据库和redis(这一块不一定需要，因为redis和postgresql版本更新的很慢)\"></a>2. 接下来build数据库和redis(这一块不一定需要，因为redis和postgresql版本更新的很慢)</h2><pre><code>cd /ICSapps/compose-file/ics\ndocker-compose stop; #把三个进程都停掉\n</code></pre><p>然后pull 数据库和redis的image:</p>\n<pre><code>docker pull docker.answ.me:5000/aplusplus/redis\ndocker pull docker.answ.me:5000/aplusplus/postgresql:9.4-13  #新的版本号,要改\ndocker-compose up -d\n</code></pre><h2 id=\"3-备份数据-如果无需更新redis和postgresql-可直接到这步\"><a href=\"#3-备份数据-如果无需更新redis和postgresql-可直接到这步\" class=\"headerlink\" title=\"3. 备份数据(如果无需更新redis和postgresql,可直接到这步)\"></a>3. 备份数据(<strong>如果无需更新redis和postgresql,可直接到这步</strong>)</h2><p>先停掉gitlab:</p>\n<pre><code>docker-compose stop gitlab\nscreen -S i\n</code></pre><p>修改<strong>backup.sh</strong>中的版本,然后运行该脚本,进行数据备份(修改为这次要备份的版本号),这个过程要花费一些时间</p>\n<h2 id=\"4-重新启动\"><a href=\"#4-重新启动\" class=\"headerlink\" title=\"4. 重新启动\"></a>4. 重新启动</h2><pre><code>docker-compose stop\ndocker-compose rm -vf #删除已经stop的container,container里边不存有数据,因为数据都在数据库和挂载到主机的目录里,因此可以放心删除之\nvi docker-compose.yml #修改所有的版本号,三个软件的\ndocker-compose up -d\n</code></pre><p>最后更新完成,全程需要root权限。</p>\n","excerpt":"","more":"<h2 id=\"1-build新版本的gitlab的docker-image文件\"><a href=\"#1-build新版本的gitlab的docker-image文件\" class=\"headerlink\" title=\"1. build新版本的gitlab的docker image文件\"></a>1. build新版本的gitlab的docker image文件</h2><pre><code>cd ~/dockerimages/gitlab/no-nrpe;\n</code></pre><p>修改Dockerfile中FROM指令gitlab为最新版本号,然后:</p>\n<pre><code>docker build -t docker.answ.me:5000/aplusplus/gitlab:8.5.1 .     #本次更新的版本号为8.5.1\n</code></pre><p>build过程时间会略长,之后会生成新的gitlab image文件，之后的过程都在/ICSapps/compose-file/ics目录下：</p>\n<pre><code>cd /ICSapps/compose-file/ics\n</code></pre><h2 id=\"2-接下来build数据库和redis-这一块不一定需要，因为redis和postgresql版本更新的很慢\"><a href=\"#2-接下来build数据库和redis-这一块不一定需要，因为redis和postgresql版本更新的很慢\" class=\"headerlink\" title=\"2. 接下来build数据库和redis(这一块不一定需要，因为redis和postgresql版本更新的很慢)\"></a>2. 接下来build数据库和redis(这一块不一定需要，因为redis和postgresql版本更新的很慢)</h2><pre><code>cd /ICSapps/compose-file/ics\ndocker-compose stop; #把三个进程都停掉\n</code></pre><p>然后pull 数据库和redis的image:</p>\n<pre><code>docker pull docker.answ.me:5000/aplusplus/redis\ndocker pull docker.answ.me:5000/aplusplus/postgresql:9.4-13  #新的版本号,要改\ndocker-compose up -d\n</code></pre><h2 id=\"3-备份数据-如果无需更新redis和postgresql-可直接到这步\"><a href=\"#3-备份数据-如果无需更新redis和postgresql-可直接到这步\" class=\"headerlink\" title=\"3. 备份数据(如果无需更新redis和postgresql,可直接到这步)\"></a>3. 备份数据(<strong>如果无需更新redis和postgresql,可直接到这步</strong>)</h2><p>先停掉gitlab:</p>\n<pre><code>docker-compose stop gitlab\nscreen -S i\n</code></pre><p>修改<strong>backup.sh</strong>中的版本,然后运行该脚本,进行数据备份(修改为这次要备份的版本号),这个过程要花费一些时间</p>\n<h2 id=\"4-重新启动\"><a href=\"#4-重新启动\" class=\"headerlink\" title=\"4. 重新启动\"></a>4. 重新启动</h2><pre><code>docker-compose stop\ndocker-compose rm -vf #删除已经stop的container,container里边不存有数据,因为数据都在数据库和挂载到主机的目录里,因此可以放心删除之\nvi docker-compose.yml #修改所有的版本号,三个软件的\ndocker-compose up -d\n</code></pre><p>最后更新完成,全程需要root权限。</p>\n"},{"title":"ssh的密钥机制","date":"2016-03-19T00:00:00.000Z","_content":"\n一直对ssh公钥私钥机制不是很了解，今天研究了下，做个记录。\n首先我们知道ssh不是明文传输的，所以才需要加密。ssh登陆的准备工作可以分成俩个阶段。本次会话的密钥生成和认证过程。因为在时序上，认证过程晚于会话密钥的生成，因此先讲会话密钥的生成。\n\n## 会话密钥生成\n\n服务器每次sshd服务启动时，会主动去查找/etc/ssh/ssh_host*目录，如果没有公钥私钥文件，就会生成新的密钥对，这里的密钥暂且称为key1，当sshd收到客户端的连接请求时，服务器会将key1_pub发送给客户端，此处是明码传送，反正公钥就是在网络上分发给别人用的嘛，这里也不需要担心什么。同时:\n\n1. 服务器生成会话id，发送给客户端。\n2. 客户端生成会话密钥key2，设为 key2，并计算 r = id xor key2_pub。\n3. 客户端将 r 用key1_pub进行加密，结果发送给服务器。\n4. 服务器用 key1_pri进行解密，获得 r。\n5. 服务器进行 r xor id 的运算，获得 key2_pub。\n6. 至此服务器和客户端都知道了会话密钥key2_pub，以后的传输都将被key2_pub加密。\n\n可以看到，key2_pub传输是加密的。\n\n## 认证过程\n\n认证过程可以分为俩种，基于密码的认证和基于密钥机制的认证，密码认证很直观，每次客户端连接sshd服务器都要输入密码口令，这样搞不是很方便，单单每次输入密码就很麻烦，再者，比如一个账号分发给多人登陆每改一次密码就要通知多个人。更方便的做法是客户端生成一个公私钥对，这里且命名为key3，在登陆前将key3的公钥key3_pub上传到要登陆的远程sshd服务器，之后:\n\n1. 服务器生成一个随机数 x，并用 key3_pub加密后生成结果 f(x)，发送给客户端\n2. 客户端使用 key3_pri 解密 f(x) 得到 x\n3. 客户端计算 key2_pri + x 的 md5 值 n(key2_pri+x)，并发给服务器\n4. 服务器计算 key2_pub + x 的 md5 值 m(key2_pub+x)\n5. 服务器比较 m(key2_pub+x) 和 n(key2_pri+x)，两者相同则认证成功\n\n因此，认证过程的密钥和本次会话密钥是不一样的，所以一个基于密钥认证的ssh过程，涉及到三个不同的密钥对。最后的结果是，服务器持有key1_pri和key2_pub，客户端持有key2_pri和key1_pub，是不一样的，所以叫作非对称式密钥系统。同时，会话密钥是客户端随机运算产生于本次连接的，因此是暂时性的，不同的连接，会话密钥可能是不同的，此后的数据传输阶段由key1，key2参与，双向的过程都遵循公钥加密，私钥解密的原则。至于认证过程的密钥key_3，如其名，仅仅是参与认证的开始阶段而已。\n\n## 参考\n\n1. [鸟哥的linux私房菜服务篇](http://linux.vbird.org/linux_server/0310telnetssh.php)\n","source":"_posts/2016-03-19#ssh的密钥机制.md","raw":"---\ntitle: ssh的密钥机制\npermalink: ssh-key\ntags:\n\t- ssh\ndate: 2016-03-19\n---\n\n一直对ssh公钥私钥机制不是很了解，今天研究了下，做个记录。\n首先我们知道ssh不是明文传输的，所以才需要加密。ssh登陆的准备工作可以分成俩个阶段。本次会话的密钥生成和认证过程。因为在时序上，认证过程晚于会话密钥的生成，因此先讲会话密钥的生成。\n\n## 会话密钥生成\n\n服务器每次sshd服务启动时，会主动去查找/etc/ssh/ssh_host*目录，如果没有公钥私钥文件，就会生成新的密钥对，这里的密钥暂且称为key1，当sshd收到客户端的连接请求时，服务器会将key1_pub发送给客户端，此处是明码传送，反正公钥就是在网络上分发给别人用的嘛，这里也不需要担心什么。同时:\n\n1. 服务器生成会话id，发送给客户端。\n2. 客户端生成会话密钥key2，设为 key2，并计算 r = id xor key2_pub。\n3. 客户端将 r 用key1_pub进行加密，结果发送给服务器。\n4. 服务器用 key1_pri进行解密，获得 r。\n5. 服务器进行 r xor id 的运算，获得 key2_pub。\n6. 至此服务器和客户端都知道了会话密钥key2_pub，以后的传输都将被key2_pub加密。\n\n可以看到，key2_pub传输是加密的。\n\n## 认证过程\n\n认证过程可以分为俩种，基于密码的认证和基于密钥机制的认证，密码认证很直观，每次客户端连接sshd服务器都要输入密码口令，这样搞不是很方便，单单每次输入密码就很麻烦，再者，比如一个账号分发给多人登陆每改一次密码就要通知多个人。更方便的做法是客户端生成一个公私钥对，这里且命名为key3，在登陆前将key3的公钥key3_pub上传到要登陆的远程sshd服务器，之后:\n\n1. 服务器生成一个随机数 x，并用 key3_pub加密后生成结果 f(x)，发送给客户端\n2. 客户端使用 key3_pri 解密 f(x) 得到 x\n3. 客户端计算 key2_pri + x 的 md5 值 n(key2_pri+x)，并发给服务器\n4. 服务器计算 key2_pub + x 的 md5 值 m(key2_pub+x)\n5. 服务器比较 m(key2_pub+x) 和 n(key2_pri+x)，两者相同则认证成功\n\n因此，认证过程的密钥和本次会话密钥是不一样的，所以一个基于密钥认证的ssh过程，涉及到三个不同的密钥对。最后的结果是，服务器持有key1_pri和key2_pub，客户端持有key2_pri和key1_pub，是不一样的，所以叫作非对称式密钥系统。同时，会话密钥是客户端随机运算产生于本次连接的，因此是暂时性的，不同的连接，会话密钥可能是不同的，此后的数据传输阶段由key1，key2参与，双向的过程都遵循公钥加密，私钥解密的原则。至于认证过程的密钥key_3，如其名，仅仅是参与认证的开始阶段而已。\n\n## 参考\n\n1. [鸟哥的linux私房菜服务篇](http://linux.vbird.org/linux_server/0310telnetssh.php)\n","slug":"ssh-key","published":1,"updated":"2016-03-22T13:13:36.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimba54vx000c06ome4tbygni","content":"<p>一直对ssh公钥私钥机制不是很了解，今天研究了下，做个记录。<br>首先我们知道ssh不是明文传输的，所以才需要加密。ssh登陆的准备工作可以分成俩个阶段。本次会话的密钥生成和认证过程。因为在时序上，认证过程晚于会话密钥的生成，因此先讲会话密钥的生成。</p>\n<h2 id=\"会话密钥生成\"><a href=\"#会话密钥生成\" class=\"headerlink\" title=\"会话密钥生成\"></a>会话密钥生成</h2><p>服务器每次sshd服务启动时，会主动去查找/etc/ssh/ssh_host*目录，如果没有公钥私钥文件，就会生成新的密钥对，这里的密钥暂且称为key1，当sshd收到客户端的连接请求时，服务器会将key1_pub发送给客户端，此处是明码传送，反正公钥就是在网络上分发给别人用的嘛，这里也不需要担心什么。同时:</p>\n<ol>\n<li>服务器生成会话id，发送给客户端。</li>\n<li>客户端生成会话密钥key2，设为 key2，并计算 r = id xor key2_pub。</li>\n<li>客户端将 r 用key1_pub进行加密，结果发送给服务器。</li>\n<li>服务器用 key1_pri进行解密，获得 r。</li>\n<li>服务器进行 r xor id 的运算，获得 key2_pub。</li>\n<li>至此服务器和客户端都知道了会话密钥key2_pub，以后的传输都将被key2_pub加密。</li>\n</ol>\n<p>可以看到，key2_pub传输是加密的。</p>\n<h2 id=\"认证过程\"><a href=\"#认证过程\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h2><p>认证过程可以分为俩种，基于密码的认证和基于密钥机制的认证，密码认证很直观，每次客户端连接sshd服务器都要输入密码口令，这样搞不是很方便，单单每次输入密码就很麻烦，再者，比如一个账号分发给多人登陆每改一次密码就要通知多个人。更方便的做法是客户端生成一个公私钥对，这里且命名为key3，在登陆前将key3的公钥key3_pub上传到要登陆的远程sshd服务器，之后:</p>\n<ol>\n<li>服务器生成一个随机数 x，并用 key3_pub加密后生成结果 f(x)，发送给客户端</li>\n<li>客户端使用 key3_pri 解密 f(x) 得到 x</li>\n<li>客户端计算 key2_pri + x 的 md5 值 n(key2_pri+x)，并发给服务器</li>\n<li>服务器计算 key2_pub + x 的 md5 值 m(key2_pub+x)</li>\n<li>服务器比较 m(key2_pub+x) 和 n(key2_pri+x)，两者相同则认证成功</li>\n</ol>\n<p>因此，认证过程的密钥和本次会话密钥是不一样的，所以一个基于密钥认证的ssh过程，涉及到三个不同的密钥对。最后的结果是，服务器持有key1_pri和key2_pub，客户端持有key2_pri和key1_pub，是不一样的，所以叫作非对称式密钥系统。同时，会话密钥是客户端随机运算产生于本次连接的，因此是暂时性的，不同的连接，会话密钥可能是不同的，此后的数据传输阶段由key1，key2参与，双向的过程都遵循公钥加密，私钥解密的原则。至于认证过程的密钥key_3，如其名，仅仅是参与认证的开始阶段而已。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://linux.vbird.org/linux_server/0310telnetssh.php\" target=\"_blank\" rel=\"external\">鸟哥的linux私房菜服务篇</a></li>\n</ol>\n","excerpt":"","more":"<p>一直对ssh公钥私钥机制不是很了解，今天研究了下，做个记录。<br>首先我们知道ssh不是明文传输的，所以才需要加密。ssh登陆的准备工作可以分成俩个阶段。本次会话的密钥生成和认证过程。因为在时序上，认证过程晚于会话密钥的生成，因此先讲会话密钥的生成。</p>\n<h2 id=\"会话密钥生成\"><a href=\"#会话密钥生成\" class=\"headerlink\" title=\"会话密钥生成\"></a>会话密钥生成</h2><p>服务器每次sshd服务启动时，会主动去查找/etc/ssh/ssh_host*目录，如果没有公钥私钥文件，就会生成新的密钥对，这里的密钥暂且称为key1，当sshd收到客户端的连接请求时，服务器会将key1_pub发送给客户端，此处是明码传送，反正公钥就是在网络上分发给别人用的嘛，这里也不需要担心什么。同时:</p>\n<ol>\n<li>服务器生成会话id，发送给客户端。</li>\n<li>客户端生成会话密钥key2，设为 key2，并计算 r = id xor key2_pub。</li>\n<li>客户端将 r 用key1_pub进行加密，结果发送给服务器。</li>\n<li>服务器用 key1_pri进行解密，获得 r。</li>\n<li>服务器进行 r xor id 的运算，获得 key2_pub。</li>\n<li>至此服务器和客户端都知道了会话密钥key2_pub，以后的传输都将被key2_pub加密。</li>\n</ol>\n<p>可以看到，key2_pub传输是加密的。</p>\n<h2 id=\"认证过程\"><a href=\"#认证过程\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h2><p>认证过程可以分为俩种，基于密码的认证和基于密钥机制的认证，密码认证很直观，每次客户端连接sshd服务器都要输入密码口令，这样搞不是很方便，单单每次输入密码就很麻烦，再者，比如一个账号分发给多人登陆每改一次密码就要通知多个人。更方便的做法是客户端生成一个公私钥对，这里且命名为key3，在登陆前将key3的公钥key3_pub上传到要登陆的远程sshd服务器，之后:</p>\n<ol>\n<li>服务器生成一个随机数 x，并用 key3_pub加密后生成结果 f(x)，发送给客户端</li>\n<li>客户端使用 key3_pri 解密 f(x) 得到 x</li>\n<li>客户端计算 key2_pri + x 的 md5 值 n(key2_pri+x)，并发给服务器</li>\n<li>服务器计算 key2_pub + x 的 md5 值 m(key2_pub+x)</li>\n<li>服务器比较 m(key2_pub+x) 和 n(key2_pri+x)，两者相同则认证成功</li>\n</ol>\n<p>因此，认证过程的密钥和本次会话密钥是不一样的，所以一个基于密钥认证的ssh过程，涉及到三个不同的密钥对。最后的结果是，服务器持有key1_pri和key2_pub，客户端持有key2_pri和key1_pub，是不一样的，所以叫作非对称式密钥系统。同时，会话密钥是客户端随机运算产生于本次连接的，因此是暂时性的，不同的连接，会话密钥可能是不同的，此后的数据传输阶段由key1，key2参与，双向的过程都遵循公钥加密，私钥解密的原则。至于认证过程的密钥key_3，如其名，仅仅是参与认证的开始阶段而已。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://linux.vbird.org/linux_server/0310telnetssh.php\">鸟哥的linux私房菜服务篇</a></li>\n</ol>\n"},{"title":"adb无线连接","premalink":"adb-wireless","date":"2016-04-03T00:00:00.000Z","_content":"\n用usb adb连接Android设备到pc,只要不小心一碰触接口,file system就弹出挂载信息,烦得要死,所以用wireless连接就没这个问题了.\n\n设备与主机能互相ping通,设备中下载终端模拟器,设备要有root权限,设备中指令如下:\n    \n    su\n    \n    setprop service.adb.tcp.port 5555\n\n设置了监听的端口号是5555.\n\n在pc先启动adb daemon,输入指令:\n\n    adb tcpip 5555\n\n    adb connect ip_of_android\n\n断开用指令adb disconnect ip, ok了.\n\n","source":"_posts/2016-04-03#adb无线连接.md","raw":"---\ntitle: adb无线连接 \npremalink: adb-wireless\ntags:\n    - Android\ndate: 2016-04-03\n---\n\n用usb adb连接Android设备到pc,只要不小心一碰触接口,file system就弹出挂载信息,烦得要死,所以用wireless连接就没这个问题了.\n\n设备与主机能互相ping通,设备中下载终端模拟器,设备要有root权限,设备中指令如下:\n    \n    su\n    \n    setprop service.adb.tcp.port 5555\n\n设置了监听的端口号是5555.\n\n在pc先启动adb daemon,输入指令:\n\n    adb tcpip 5555\n\n    adb connect ip_of_android\n\n断开用指令adb disconnect ip, ok了.\n\n","slug":"adb无线连接","published":1,"updated":"2016-04-03T05:07:19.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimk3xjao00001bom1u448f05","content":"<p>用usb adb连接Android设备到pc,只要不小心一碰触接口,file system就弹出挂载信息,烦得要死,所以用wireless连接就没这个问题了.</p>\n<p>设备与主机能互相ping通,设备中下载终端模拟器,设备要有root权限,设备中指令如下:</p>\n<pre><code>su\n\nsetprop service.adb.tcp.port 5555\n</code></pre><p>设置了监听的端口号是5555.</p>\n<p>在pc先启动adb daemon,输入指令:</p>\n<pre><code>adb tcpip 5555\n\nadb connect ip_of_android\n</code></pre><p>断开用指令adb disconnect ip, ok了.</p>\n","excerpt":"","more":"<p>用usb adb连接Android设备到pc,只要不小心一碰触接口,file system就弹出挂载信息,烦得要死,所以用wireless连接就没这个问题了.</p>\n<p>设备与主机能互相ping通,设备中下载终端模拟器,设备要有root权限,设备中指令如下:</p>\n<pre><code>su\n\nsetprop service.adb.tcp.port 5555\n</code></pre><p>设置了监听的端口号是5555.</p>\n<p>在pc先启动adb daemon,输入指令:</p>\n<pre><code>adb tcpip 5555\n\nadb connect ip_of_android\n</code></pre><p>断开用指令adb disconnect ip, ok了.</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cimba54uk000106ompqyxn28d","tag_id":"cimba54v2000306omc5zsmalw","_id":"cimba54vl000806omdi3owjbu"},{"post_id":"cimba54uv000206om27cptimk","tag_id":"cimba54vg000606om6yjskjq2","_id":"cimba54wg000f06omc8ba6016"},{"post_id":"cimba54uv000206om27cptimk","tag_id":"cimba54vw000b06om4b28cpck","_id":"cimba54wg000g06omysl5qz2z"},{"post_id":"cimba54uv000206om27cptimk","tag_id":"cimba54wa000d06omoj833iro","_id":"cimba54wi000i06ompumfaeab"},{"post_id":"cimba54v7000406omft2xvx4p","tag_id":"cimba54wf000e06omg8edju0d","_id":"cimba54wi000j06om7xpp8yci"},{"post_id":"cimba54va000506omaps9jjnm","tag_id":"cimba54wg000h06omwxiwf4e3","_id":"cimba54wp000m06omwzkkgp58"},{"post_id":"cimba54va000506omaps9jjnm","tag_id":"cimba54wi000k06omw1slrnkt","_id":"cimba54ws000n06omxy33vvyl"},{"post_id":"cimba54vh000706omqlnjhdzz","tag_id":"cimba54wo000l06omctp9wxez","_id":"cimba54wv000q06omd3h3ipk2"},{"post_id":"cimba54vh000706omqlnjhdzz","tag_id":"cimba54wa000d06omoj833iro","_id":"cimba54ww000r06omub164vu8"},{"post_id":"cimba54vl000906om4brj9o72","tag_id":"cimba54wu000p06omob52ad0l","_id":"cimba54x0000t06omrau4l29n"},{"post_id":"cimba54vx000c06ome4tbygni","tag_id":"cimba54x0000u06omflhgt46t","_id":"cimba54x1000w06omwdf4vnss"},{"post_id":"cimk3xjao00001bom1u448f05","tag_id":"cimk3xjb000011bom5iok4nz5","_id":"cimk3xjbh00021bomdetliqks"}],"Tag":[{"name":"记录","_id":"cimba54v2000306omc5zsmalw"},{"name":"nagios","_id":"cimba54vg000606om6yjskjq2"},{"name":"mysql","_id":"cimba54vw000b06om4b28cpck"},{"name":"docker","_id":"cimba54wa000d06omoj833iro"},{"name":"生活","_id":"cimba54wf000e06omg8edju0d"},{"name":"vpn server","_id":"cimba54wg000h06omwxiwf4e3"},{"name":"linux","_id":"cimba54wi000k06omw1slrnkt"},{"name":"nginx","_id":"cimba54wo000l06omctp9wxez"},{"name":"gitlab","_id":"cimba54wu000p06omob52ad0l"},{"name":"ssh","_id":"cimba54x0000u06omflhgt46t"},{"name":"Android","_id":"cimk3xjb000011bom5iok4nz5"}]}}